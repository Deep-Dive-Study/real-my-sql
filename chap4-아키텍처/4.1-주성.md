# 04. 아키텍처

- MySQL 서버는 MySQL 엔진, 스토리지 엔진으로 구분됨

- 누구나 핸들러 API 만족하는 구현체(스토리지 엔진)를 구현하면 MySQL 서버에 추가해서 사용할 수 있음 

- 기본 제공 스토리지 엔진으로는 `InnoDB`, `MyISAM` 있음


## 4.1 MySQL 엔진 아키텍처

- MySQL 서버는 다른 DBMS에 비행 구조가 독특함

  - 이러한 구조가 혜택이 되는 반면 문제가 되는 부분도 있다
    
#### 4.1.1 MySQL의 전체 구조

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/e19baf27-d7d6-487e-80d9-7d5c8f22da5e)

- 대부분의 프로그래밍 언어로 부터 접근 방법을 지원 ex) JDBC, ODBC, etc..
  
- 크게 MySQL 엔진, 스토리지 엔진 구분 됨 (합쳐서 MySQL 서버로 부른다)

#### 4.1.1.1 MySQL 엔진
  - 커넥션 핸들러 (클라이언트로부터 접속 및 쿼리 요청을 처리)
  - SQL 인터페이스 (표준SQL인 ANSI SQL 문법 지원)
  - SQL 파서
  - 전처리기
  - 옵티마이저 (쿼리의 최적화된 실행을 위함)
    
    - 요청된 SQL 문장을 분석 및 최적화
  - 캐시 및 버퍼
    
#### 4.1.1.2 스토리지 엔진
  
  - 실제 데이터를 디스크에 저장하거나 디스크로부터 데이터를 읽어옴
    
  - MySQL 엔진은 하나지만, 스토리지 엔진은 여러 개 동시에 사용 가능
    
  - 다음과 같이 테이블이 사용할 스토리지 엔진을 지정하면, 이후 해당 테이블의 모든 읽기 작업이나 변경 작업은 정의된 스토리지 엔진이 처리한다
        
  ```sql
  CREATE TABLE test_table(fd1 INT, fd2 INT) ENGINE=INNODB;
  ```
        
  - 각 스토리지 엔진은 성능 향상을 위한 기능을 내장하고 있다
    
    - 키 캐시(MyISAM 스토리지 엔진)
      
    - InnoDB 버퍼 풀(InnoDB 스토리지 엔진)

#### 4.1.1.3 핸들러 API

- MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는, 각 스토리지 엔진에 쓰기 또는 읽기를 요청함

  - 이러한 요청을 핸들러 요청이라 하고, 여기서 사용되는 API를 **`핸들러 API`** 라고 한다
 
- 얼마나 많은 데이터(레코드) 작업이 있었는지 확인 가능
  
  ```sql
  SHOW GLOBAL STATUS LIKE 'Handler%';
  ```
  
##### 결과

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/86278e7d-f264-4384-9f7c-588df7a319f5)

### 4.1.2 MySQL 스레딩 구조

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/89bfd15b-2370-415c-ac63-4e86b044aeae)

- MySQL 서버는 스레드 기반으로 작동 (`포그라운드 스레드`, `백그라운드 스레드`로 구분)

#### 실행중인 스레드 확인

  ```sql
  SELECT thread_id, name, type, processlist_user, processlist_host
  FROM performance_schema.threads ORDER BY type, thread_id;
  ```

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/7f877fa7-5a32-49dc-bb10-dc36e8a2d09e)

#### 4.1.2.1 포그라운드 스레드(클라이언트 스레드)

- 서버에 접속한 클라이언트 수(커넥션) 만큼 존재 

  - 엔터프라이즈 버전에선 스레드 풀로 관리 되기 때문에 다를 수 있음
    
  - 작업이 끝나면 스레드 캐시로 되돌아 감, 스레드 캐시에 대기할 수 있는 개수는 `thread_cache_size`로 관리  
  
- 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
  
  - 데이터 버퍼나 캐시로부터 데이터를 가져옴
  
  - 버퍼나 캐시에 없는 경우에는, 직접 디스크나 인덱스 파일로부터 데이터를 읽어와 처리
  
- `디스크 쓰기 작업`
  
  - InnoDB 테이블의 경우는, 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리함

  - MyISAM 테이블의 경우는, 디스크 쓰기 작업까지 포그라운드 스레드가 처리 (지연된 쓰기가 있긴 하지만, 일반적인 방법은 아니다)

- 사용자 스레드

  - 사용자가 요청한 작업을 처리하기 때문에 사용자 스레드라고도 함 (포그라운드랑 동일)
  
  - 클라이언트가 MySQL 서버에 접속하게 되면, MySQL 서버는 해당 클라이언트의 요청을 처리해줄 스레드를 생성해 할당

#### 4.1.2.2 백그라운드 스레드

- InnoDB는 다음과 같이 여러 가지 작업을 백그라운드로 처리한다
   
  - 인서트 버퍼를 병합하는 스레드
  - **로그를 디스크로 기록하는 스레드** (로그 스레드)
  - **InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드** (쓰기 스레드)
  - 데이터를 버퍼로 읽어오는 스레드
  - 잠금이나 데드락을 모니터링하는 스레드

- MySQL5.5 버전부터 읽기 스레드와 쓰기 스레드를 2개 이상 지정 가능

  - `innodb_write_io_threads`,`innodb_read_io_threads` 변수로 개수 설정
    
- `쓰기 지연`
  
  - **쓰기 작업을 버퍼링해서 일괄 처리하는 기능**

  - MyISAM에선 제공 X, InnoDB에서만 제공 (일반적인 사용 DBMS도 대부분 제공함)


### 4.1.3 메모리 할당 및 사용 구조

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/860ea20e-d79d-470d-bcbf-43c16c1cac88)

- MySQL에서 사용되는 메모리 공간은 크게 `글로벌 메모리 영역`, `로컬 메모리 영역`으로 구분
  
#### 4.1.3.1 글로벌 메모리 영역

- MySQL 서버 실행시 운영체제로 부터 할당 받음
  
  - 할당량은 복잡하니 시스템 변수로 설정해 둔 만큼 메모리를 할당 받는다고 생각하면 됨 

- 클라이언트 스레드의 수와 무관하게 일반적으로 하나의 메모리 공간만 할당
  
- 생성된 글로벌 영역이 N개라 하더라도 **모든 스레드에 의해 공유됨**
  
- 글로벌 메모리 영역
  
    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼

#### 4.1.3.2 로컬 메모리 영역

- 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역

  - 세션 메모리 영역, 클라이언트 메모리 영역이라고도 부름
 
- 각 클라이언트 스레드별로 **독립적** 으로 할당된다
  
  - 절대 공유되어 사용되지 않음
    
- 로컬 메모리 영역
  
    - 소트 버퍼
    - 조인 버퍼
    - 바이너리 로그 캐시
    - 네트워크 버퍼
      
- 각 쿼리의 용도별로 필요할 때만 공간이 할당되고, 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차도 하지 않을수도 있다
  
  - **커넥션 버퍼나 결과 버퍼** : 커넥션이 열려있는 동안 계속 할당된 상태로 남음
    
  - **소트 버퍼나 조인 버퍼** : 쿼리를 실행하는 순간에만 할당했다가 다시 해제

### 4.1.4 플러그인 스토리지 엔진 모델

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/68dba33e-9ed8-4695-8f0a-baf7c1acb971)

- MySQL만의 독특한 구조

- MySQL 서버에서는 스토리지 엔진 뿐만 아니라 다양한 기능을 플러그인 형태로 지원함
  
  - 인증이나 전문검색 파서 또는 쿼리 재작성 플러그인
    
  - 비밀번호 검증과 커넥션 제어와 관련된 플러그인
 
  - 등등 다양한 플러그인을 제공. (만약 부가적인 기능을 더 필요한 경우 사용자가 직접 개발해서 사용 가능)
  

#### MySQL에서 쿼리가 실행되는 과정

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/cc0828a4-4d97-4d47-9507-de23a039046d)

- 거의 대부분의 작업이 MySQL 엔진에서 처리되고, 마지막 **‘데이터 읽기/쓰기’** 작업만 스토리지 엔진에서 처리

  - MySQL엔진은 사람의 역할이라면, 스토리지 엔진은 자동차 역할

  - 자동차를 조정하기 위해 `핸들러(API)`를 사용

  - 하나의 쿼리는 여러 하위 작업으로 나뉘어 지는데 각 작업이 어느 영역에서 처리되는지 구분할 줄은 알아야 함 

#### MySQL 서버(mysqld)에서 지원되는 스토리지 엔진

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/32647485-dae3-4b0b-ac96-392b1905214a)

- YES : MySQL 서버에 해당 스토리지 엔진이 포함돼 있고, 사용 가능으로 활성화된 상태
- DEFAULT : YES와 동일한 상태지만 필수 스토리지 엔진임을 의미
- NO : MySQL 서버에 포함되지 않았음을 의미
- DISABLED : 현재 MySQL 서버에는 포함됐지만 파라미터에 의해 비활성화된 상태
<br />

- MySQL 서버에 포함되지 않은 스토리지 엔진을 사용하려면(Support가 NO인 엔진), MySQL 서버를 다시 빌드해야 함
  
  - 플러그인 형태로 빌드된 스토리지 엔진은 라이브러리를 다운로드해서 끼워넣기만 하면 사용 가능

    - 손쉽게 업그레이드 가능 
  
  - `SHOW PLUGINS` 명령으로 스토리지 엔진 뿐 아니라, 인증 및 전문검색용 파서 같은 플러그인도 확인할 수 있음

- MySQL 서버의 기능을 커스텀하게 확장할 수 있게 플러그인 API가 메뉴얼에 공개되어 있음

    - 기존 MySQL 서버에 제공하던 기능들을 확장할 수 있다
  
    - 완전히 새로운 기능들을 플러그인을 이용해 구현할 수 있다
  
### 4.1.5 컴포넌트

- MySQL 8.0부터는 기존의 플러그인 아키텍처를 대처하기 위해 **컴포넌트 아키텍처** 를 지원함

**`플러그인 단점`**

- 플러그인은 오직 MySQL 서버와 인터페이스 할 수 있고, 플러그인끼리는 통신할 수 없음

- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음
  
- 플러그인은 상호 의존관계를 설정할 수 없어서 초기화가 어려움
  
#### 컴포넌트는 이러한 단점들을 보완해서 구현함

- 컴포넌트도 플러그인과 마찬가지로 추가시 새로운 시스템 변수를 설정해야 할 수 있으니 관련 메뉴얼을 잘 활용하자

- 컴포넌트와 플러그인 둘 다, 사용자 입장에서는 **서버의 기능을 동적으로 확장하는 방법**

- MySQL 5.7 버전까지는 비밀번호 검증 기능이 플러그인 형태로 제공됐지만 MySQL 8.0의 비밀번호검증 기능은 컴포넌트로 개선됐다
    
    ```sql
    -- // validate_password 컴포넌트 설치
    INSTALL COMPNENT 'file://component_validate_password';

    -- // 설치된 컴포넌트 확인
    SELECT * FROM mysql.component;
    ```

### 4.1.6 쿼리 실행 구조

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/edfde6b5-82d6-4dd1-9ff4-b1f81a005ca3)

#### 4.1.6.1 쿼리 파서
- 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리하여 트리 형태의 구조를 만드는 작업을 수행

- 쿼리 문장의 기본 문법 오류 처리

#### 4.1.6.2 전처리기
- 파서 과정에서 만들어진 파서 트리를 기반으로, 쿼리 문장에 구조적인 문제를 확인

- 테이블 이름, 칼럼 이름, 내장 함수같은 개체를 매핑하여 해당 객체의 존재 여부, 객체의 접근권한 등을 확인

- 실제 존재하지 않거나, 권한상 사용할 수 없는 개체의 토큰을 처리
    
#### 4.1.6.3 옵티마이저
- 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할을 담당

- DBMS의 두뇌로 가장 중요한 역할

#### 4.1.6.4 실행 엔진
- 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청, 받은 결과를 또다른 핸들러 요청의 입력으로 연결한다

#### 4.1.6.5 핸들러(스토리지 엔진)
- 핸들러는 MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할

- MyISAM 테이블을 조작하는 경우에는 핸들러가 MyISAM 스토리지 엔진이 되고, InnoDB 테이블을 조작하는 경우에는 핸들러는 InnoDB 스토리지 엔진이 됨

### 4.1.7 복제
- MySQL 서버에서 복제(Replication)은 매우 중요한 역할로 많은 발전을 거듭함 (16장에서 자세히 다룰 예정) 

### 4.1.8 쿼리 캐시

- 쿼리 캐시는 SQL의 실행 결과를 메모리에 캐시하고, 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환하기 때문에 빠른 성능을 보여줌
  
- 하지만 쿼리 캐시는 테이블의 데이터가 변경되면 캐시에 저장된 결과 중에서 변경된 테이블과 관련된 것들을 모두 삭제해야 했다
  
  → **`심각한 동시처리 성능 저하`** , **`많은 버그의 원인`** 

- 데이터 변경은 거의 없고 읽기만 하는 서비스에는 매우 훌륭한 기능

- MySQL 8.0으로 올라오면서 쿼리 캐시는 MySQL 서버의 기능에서 완전히 제거됨 (관련된 시스템 변수도 모두 제거됨)

### 4.1.9 스레드 풀

- 커뮤니티 에디션은 미지원
  
  - 커뮤니티 에디션 서버에 스레드풀 기능을 사용하고자 한다면, Percona Server에서 스레드풀 플러그인 라이브러리(thread_pool.so)를 설치(INSTALL PLUGIN 명령)해서 사용하면 된다

**`사용 목적`**

- 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다 하더라도 **MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게** 해서 서버의 자원 소모를 줄임

  - 다만, 실제로 스레드 풀이 실제 서비스에서 눈에 띄는 성능 향상을 보여준 경우는 드물었다

- 스레드 풀은 스레드들을 CPU가 최대한 잘 처리해낼 수 있는 수준으로 줄여서 빨리 처리하게 하는 기능

  - 즉, 스케줄링 과정에서 CPU 시간을 제대로 확보하지 못하는 경우에는 오히려 쿼리 처리가 더 느려질 수 있기 때문에 주의가 필요함

  - 적절한 사용한다면 CPU의 프로세스 친화도(Processor affinity)도 높이고 불필요한 컨텍스트 스위치(Context switch)의 오버헤드를 낮출 수 있음 
<br />

- Percona Server의 스레드 풀은 기본적으로 **CPU 코어의 개수**만큼 스레드 그룹을 생성함

  - `thread_pool_size` 변수로 조정 가능

  - `thread_pool_oversubscribe` 변수에 설정된 개수만큼 추가로 생성 (해당 값이 크면 비효율적으로 작동할 가능성이 있음)

- 스레드 그룹의 모든 스레드가 일을 처리하고 있다면 새로운 작업 스레드를 추가할지, 기존 작업 스레드가 처리를 완료할 때까지 기다릴지 여부를 판단해야 함

   - 스레드 풀의 타이머 스레드가 주기적으로 스레드 그룹의 상태를 체크 하고 `thread_pool_stall_limit` 변수를 확인
     
      - 이 시스템 변수에 정의된 시간(밀리 초)만큼 작업 스레드가 지금 처리중인 작업을 끝내지 못하면, 새로운 스레드를 생성해서 스레드 그룹에 추가
      
      - 응답 시간에 아주 민감한 서비스라면 이 설정값을 적절히 낮춰서 설정해야 함
      
      -  그렇다고 해서 0에 가까운 값으로 설정한다면, 스레드 풀을 사용하지 않는 편이 더 낫다
      
      -  `thread_pool_max_threads`에 설정된 개수를 넘을 수는 없음

- Percona의 스레드 풀 플러그인은 선순위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능을 제공함
  
  - 작업 순서를 재배치함으로써 트랜잭션들이 최대한 빨리 종료될 수 있게함
  
    - 먼저 시작된 트랜잭션 내에 속한 SQL을 빨리 처리해주면 해당 트랜잭션이 가지고 있던 잠금이 빨리 해제되고 잠금 경합을 낮춰서 전체적인 처리 성능이 향상됨 

##### Percona Server의 스레드 풀에서 지원하는 선순위 큐와 후순위 큐를 이용해 재배치한 작업의 순서        

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/7900431a-7635-43f9-8621-5da510256773)

### 4.1.10 트랜잭션 지원 메타데이터

**`메타데이터(데이터 딕셔너리)`**

- 테이블의 구조 정보와 스토어드 프로그램 등의 정보
  
#### MySQL 5.7 vs MySQL 8.0

- MySQL 5.7까지는 테이블의 구조를 FRM 파일에 저장하고 일부 스토어드 프로그램 또한 파일 기반으로 관리함
  
    - 파일 기반의 메타데이터는 생성/변경 작업에 트랜잭션을 지원하지 않음
      
    - 따라서, 테이블의 생성 또는 변경 도중에 MySQL 서버가 비정상적으로 종료하게 되면 일관성이 깨진 상태로 남는 문제가 있었음
      
- MySQL 8.0부터는 `시스템 테이블`들을 모두 InnoDB 스토리지 엔진을 사용하도록 개선
  
  - `시스템 테이블` : MySQL 서버가 작동하는데 기본적으로 필요한 테이블들 ex) 사용자의 인증과 권한에 관련된 테이블들

    - 시스템 테이블과 데이터 딕셔너리 정보를 모두 모아서 mysql DB에 저장 (`mysql.ibd`라는 이름의 테이블스페이스에 저장됨) 
    
  - 트랜잭션 지원
    
    - 스키마 변경 작업 중간에 MySQL 서버가 비정상적으로 종료하게 되더라도 스키마 변경은 완전한 성공이거나 완전한 실패를 보장
   
- MyISAM, CSV 등과 같은 스토리지 엔진의 메타 정보는 저장할 공간이 필요함

  - **SDI(Serialized Dictionary Infomation)포맷**을 제공함 (*.FRM과 동일한 역할)

  - 이는 직렬화(Serialized)를 위한 포맷이므로 InnoDB 테이블의 구조도 SDI파일로 변환 가능

    - ibd2sdi 유틸리티를 이용하면 InnoDB 테이블스페이스에서 스키마 정보 추출 가능 

#### 테이블과 컬럼 정보 뷰
- 실제 mysql DB에서 테이블의 목록을 살펴보면 실제 테이블의 구조가 저장된 테이블은 보이지 않음
 
- 데이터 딕셔너리 테이블의 데이터를 사용자가 임의로 수정하지 못하게 사용자의 화면에 보여주지만 않을 뿐 실제로는 존재함
  
    - mysql DB에서 tables라는 이름의 테이블에 대해 SELECT를 실행해보면 ‘테이블이 없음’ 에러가 아니라 ‘접근이 거절됨’이 표시됨

- 대신 MySQL 서버는 데이터 딕셔너리 정보를 information_schema DB의 TABLES와 COLUMNS 등과 같은 뷰를 통해서 조회 가능함
