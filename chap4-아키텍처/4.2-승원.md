# 4-2장 InnoDB 엔진 아키텍처

InnoDB는 MySQL엔진중 거의 유일하게 레코드 기반의 잠금을 제공한다. 그렇기 때문에 동시성 처리가 가능하고, 안정성과 성능이 뛰어나다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/9d4d221d-ba6e-467c-981a-72fb0b25a861)

위 사진은 InnoDB의 아키텍처인데, 특징을 살펴보도록 하자.

### **PK에 의한 클러스터링**

InnoDB의 모든 테이블은 PK를 기준으로 클러스팅 되어 저장된다. 이게 무슨말이냐면, PK순서대로 디스크에 저장되며, **다른 인덱스들은 PK의 값을 논리적인 주소**로 사용한다.

PK가 클러스터링 인덱스이기 때문에 **레인지 스캔은 상당히 빠르게** 처리된다. 그렇기 때문에 실행계획에서 다른 인덱스보다 PK가 선택될 확률이 높다.

MyISAM은 클러스터링 키를 지원하지 않기 때문에 PK와 다른 인덱스는 구조적인 차이가 없다.

### **FK 지원**

InnoDB에서 FK는 부모, 자식 테이블 모두 해당 칼럼에 인덱스를 생성하고, 변경시에 부모 자식 모두 체크한다. 이와 같은 특성으로 인해 여러 테이블로 전파되어 데드락을 야기하기도 한다.

수동으로 데이터 적재, 스키마 변경 작업등을 진행할때 실패할 수 있다. 이런 경우 `foreign_key_checks` 시스템 변수를 OFF로 변경하고 작업할 수 있다.(cascade무시)속성을 다시 ON 하기전에 부모, 자식 간의 일관성을 맞춰줘야 한다.

### **MVCC(Multi Version Concurrency Controll)**

MVCC의 뜻은 하나의 레코드를 여러 버전으로 관리한다는 뜻이며, 가장 큰 목적은 lock 없이 읽관된 읽기이다. InnoDB는 언두 로그를 통해 이 기능을 제공한다. 

다음은 m_area가 서울에서 경기로 바뀌는 경우에 언두 로그의 변화를 나타낸 사진이다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/cfb45ab7-41c7-4aa6-90eb-60a78b12310d)

커밋 여부와 상관없이 UPDATE 쿼리와 함께 버퍼풀은 변경되고, 기존 값은 언두 로그에 적재된다. 디스크는 보통 버퍼풀과 동일하지만 아닐 수 있다.

이때 **트랜잭션의 격리 수준에 따라서 어느 영역의 데이터**를 반환할지 결정된다.

커밋이 된다면 버퍼풀은 즉시 디스크에 반영되고, 트랜잭션이 사라지면 해당하는 언두 로그는 삭제한다.

**잠금 없는 일관된 읽기**

격리 수준이 SERIALIZABLE이 아닌 경우 SELECT 작업은 잠금을 대기하지 않고 바로 실행된다. 위의 사진과 같이 커밋되지 않은 데이터여도 언두 로그를 통해 잠금없이 SELECT 작업을 실행한다.

오랜시간 활성화된 트랜잭션으로 인해 언두 로그가 쌓여 서버가 느려지거나 문제가 발생하는경우도 있다. 따라서 트랜잭션이 시작되었다면 가능한 롤백/커밋을 해주자.

### **자동 데드락 감지**

InnoDB는 내부적으로 Wait-for List를 관리한다. 데드락 감지 스레드가 주기적으로 Wait-for List를 검사해 교착상태의 트랜잭션중 하나를 강제 종료한다.

강제 종료의 기준은 트랜잭션의 언두 로그 양이다. 언두 로그의 양이 적다면 트랜잭션 롤백으로 인한 부하가 적다는 뜻이다.

데드락 감지 스레드는 잠금 상태가 변경되지 않도록 잠금 테이블에 잠금을 거는데, 동시 처리가 많아지는 경우 데드락 감지가 느려져 서비스에 악영향을 미치게 된다. 따라서 `innodb_deadlock_detect` 를 OFF로 설정하면 데드락 감지 스레드를 끌 수 있다. 하지만 데드락이 발생해도 무한 대기할 수 있으니 `innodb_lock_wait_timeout` 를 적절히 사용해보자.

* InnoDB 스토리지 엔진의 상위 레이어인 MySQL 엔진에서 관리되는 테이블 lock은 스토리지 엔진에서 볼 수 없어서 데드락 감지가 불확실할 수 있다. `innodb_table_locks` 시스템 변수를 활용하면 테이블 레벨의 lock을 감지할 수 있다. 왠만하면 활성화 하자.

### **장애 복구 자동화**

InnoDB는 MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대한 일련 복구 작업을 자동으로 실행한다. 이 때 자동으로 복구될 수 없는 손상이 있는 경우 MySQL 서버가 종료된다.

이럴땐 `innodb_force_recovery`를 설정해서 서버를 시작해야 한다. 

일단 서버가 기동되고, InnoDB 테이블이 인식된다면 mysqldump를 이용해 데이터를 백업하고 DB와 테이블을 다시 생성하는 것이 좋다.

설정 값은 1부터 6까지 있는데, 높을 수록 심각한 문제다. 0이 아닌 복구모드에선 select 쿼리만 수행 가능하다.

1. InnoDB의 테이블 스페이스의 데이터나 인덱스 페이지에 손상된 부분을 무시하고 서버를 시작한다. (Database page corruption on dist or a failed 메세지 발생시)
2. 백그라운드 스레드중 메인 스레드를 시작하지 않고 서버를 기동한다. (언두로그 삭제하는 과정에서 장애 발생)
3. MySQL서버는 실행시 언두 영역의 데이터를 적용하고, 리두 로그 내용을 덮어씌워 장애 시점의 데이터를 만들고 커밋되지 않은 트랜잭션을 롤백한다. 속성 값을 3으로 설정하게 되면 롤백을 하지 않는다.
4. insert buffer의 내용을 무시하고 강제로 서버를 기동한다. insert buffer는 실제 데이터와 관련되지 않아서 DB손실 없이 복구 가능하다.(insert buffer의 손상이 있는 경우)
5. 언두 로그를 무시하고 서버를 기동한다. (트랜잭션 실행중 MySQL 서버를 종료한다면 언두 레코드에 적재하는데, 언두 로그를 사용할 수 없는 경우)
6. 리두 로그를 무시하고 서버를 기동한다. 리두 로그가 손상되는 경우 마지막 체크포인트 시점의 데이터만 남게 되는데, 기존의 리두 로그를 모두 삭제하고 mysqldump를 이용하자.(리두 로그가 손상된 경우)

위의 방법을 사용해도 서버가 시작하지 않으면 백업을 이용하는 방법밖에 없다.

### **버퍼 풀**

InnoDB의 가장 **핵심**이다. 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐싱하는 공간이다. 쓰기작업을 지연해 일괄처리하는 버퍼 역할도 한다.

버퍼 풀은 128MB 청크 단위로 쪼개서 관리 되기 때문에 늘리거나 줄일때의 단위로 사용된다. `innodb_buffer_pool_instance` 를 이용해 버퍼 풀을 여러개로 분리해서 관리하는데 이를 인스턴스라고 부른다.

MySQL 5.7부터 버퍼 풀의 크기를 동적으로 조절할 수 있어, 작은 값으로 시작해 조금씩 증가시키는 방법이 최적이다. `innodb_buffer_pool_size` 시스템 변수로 크기를 설정할 수 있다. 버퍼 풀의 크기를 줄이는 작업은 시스템 영향도가 매우 크니 주의하자.

**버퍼풀 구조**

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/b2cdf4cf-1541-414f-a2e4-c925e2eed4a3)

버퍼 풀을 페이지 크기(innodb_page_size)로 쪼개어 저장하는데, 페이지를 관리하기 위해 크게 LRU(Least Recently Used), Flush, Free라는 자료구조를 관리한다. 

- Free 실제 사용자 데이터로 채워지지 않은 비어있는 페이지 목록이다.
- Flush 디스크로 동기화되지 않은 데이터를 가진 페이지(더티 페이지)
- LRU 디스크로부터 한 번 읽어온 페이지를 최대한 메모리에 유지하기 위해 존재하는 곳. MRU와 LRU가 섞인 모습이다. 데이터 페이지를 찾는 과정은 다음과 같다.
1. 필요한 레코드가 있는 페이지를 찾는다.
2. 디스크에서 페이지를 버퍼 풀에 적재하고 LRU 헤더에 추가한다.
3. LRU의 헤더에 적재된 페이지가 읽히면 MRU 헤더 부분으로 이동한다.
4. 버퍼풀에 상주하는 페이지는 최근에 접근할수록 낮은 Age를 가지며 나이가 많아지면 버퍼풀에서 제거된다.
5. 데이터가 자주 접근됐다면, 해당 페이지를 어댑티브 해시 인덱스에 추가한다.

**리두 로그**

리두 로그는 1개 이상의 고정 크기 파일을 연결해서 순환 고리처럼 사용한다. 따라서 전체 리두 로그 파일에서 재사용 가능한 공간과 불가능한 공간을 구분해서 관리해야 하는데, 불가능한 공간을 활성 리두 로그라고 한다.

기록될 때마다 Log Sequence Number를 증가시킨다. InnoDB는 주기적으로 체크포인트 이벤르를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화 한다. 이때 가장 최근 체크포인트의 LSN이 시작점이 된다.

리두 로그의 크기가 크다고 무조건 좋은 것이 아니다. 크기가 크면 한 번에 많은 더티페이지를 동기화해 서버에 부하를 주기 때문이다.

**버퍼 풀 플러시**

MySQL 8.0부턴 더티 페이지 동기화 작업시 디스크 쓰기 폭증 현상은 발생하지 않는다. InnoDB는 Flush List와 LRU List를 백그라운드로 진행한다.

- Flush List
리두 로그 공간 활용을 위해 주기적으로 오래된 리드 로그 엔트리가 사용하는 공간을 비운다. 이때 버퍼풀의 더티 페이지가 먼저 동기화 해야된다. 이를 위해 Flush List 함수를 호출해서 오래된 순으로 동기화 하는 작업을 수행한다.
이때 `innodb_max_dirty_pages_pct_lwv` 을 설정해 버퍼 풀에 더티 페이지 비율을 정할 수 있다.
- LRU List
사용 빈도가 낮은 데이터 페이지들을 제거하기 위해 사용된다. 더티 페이지를 동기화 후 Free 리스트로 페이지들을 옮긴다.

**버퍼 풀 상태 백업 및 복구**

서버를 다시 시작하면 버퍼 풀이 비어있어 쿼리 처리 성능이 낮다. 이때 버퍼 풀에 데이터가 적재 되어있는 상태를 워밍업이라고 표현하는데, 재시작 하는 경우 강제 워밍업을 했었다. 하지만 MySQL 5.6부턴 버퍼 풀 덤프 및 적재 기능이 도입되어 백업할 수 있다.

**버퍼 풀 내용 확인**

information_schema에 innodb_cached_indexes 테이블을 사용해 얼마나 적재 되어있는지 조회할 수 있다.

**Double Write Buffer**

리두 로그는 공간 낭비를 막기 위해 페이지의 변경된 내용만 기록한다. 이로 인해 플러시할 때 일부만 기록되면 문제가 발생한다. 이를 막기위해 Double Write 기법을 사용한다.

데이터를 디스크에 기록하기 전에 먼저 이중 버퍼링하는 메커니즘이다. 버퍼 풀의 데이터를  Double Write 버퍼로 복사한 다음 디스크의 Double Write 영역에 기록한다.

## 언두 로그

트랜잭션과 격리 수준을 보장하기 위해 DML 변경 이전의 데이터를 별도로 백업한다.

MySQL 5.5 이전 버전에선 한 번 증가한 언두 로그 공간은 줄어들지 않았다. 하지만 MySQL 8.0에선 언두 로그를 돌아가면서 사용해 디스크 공간을 줄이기도 하고, 디스크 공간을 자동으로 줄여주기도 한다.

### 언두 테이블스페이스 관리

언두 로그가 저장되는 공간을 언두 테이블스페이스라고 한다. 기존에는 시스템 테이블스페이스에 저장되기도 했고, 별도의 언두 로그 파일을 사용하기도 했는데 MySQL 8.0부터 외부의 별도 로그 파일에 기록되도록 개선되었다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/c5d13a94-72d1-470a-9e51-7790ca82bbdb)

언두 테이블스페이스는 1~128개의 롤백 세그먼트를 가지며 롤백 세그먼트는 1개 이상의 언두 슬롯을 가진다.

MySQL 8.0부터 언두 테이블 스페이스는 Create, Drop, Alter를 통해 조작이 가능하다.

### 체인지 버퍼

InnoDB는 변경해야 할 인덱스 페이지를 디스크로부터 읽어와서 업데이트해야 한다면 즉시 실행하지 않고 체인지 버퍼에 저장 해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시킨다. 반드시 중복 여부를 체크해야 하는 유니크 인덱스는 체인지 버퍼를 사용할 수 없다. 

체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합되는데, 이 스레드를 체인지 버퍼 머지 스레드 라고 한다. MySQL 5.5 이전 버전 까지는 INSERT 작업에 대해서만 이러한 버퍼링이 가능했는데, MySOL 8.0에서는 INSERT, DELETE, UPDATE로 인해 키를 추가하거나 삭제하는 작업에 대해서도 버퍼링이 될 수 있게 개선됐다. 

MySQL 5.5 이전 버전에서는 별도의 시스템 변수 설정 없이 기본적으로 기능이 활성화 됐지만 MVSOL 5.5부터 는 `innodb_change_buffering`이라는 시스템 변수가 새로 도입되어 작업의 종류별로 체인지 버퍼를 활성 화할 수 있으며, 체인지 버퍼가 비효율적일 때는 체인지 버퍼를 사용하지 않게 설정할 수 있게 개선됐다.

### 리두 로그 및 로그 버퍼

리두 로그는 ACID의 D와 가장 밀접하게 연관돼 있다. 리두 로그는 여러가지 문제로 인해 MySQL서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치다.
변경된 데이터를 데이터 파일에 기록 하려면 상대적으로 큰 비용이 필요하다. 이로 인한 성능 저하를 막기 위해 쓰기 비용이 낮은 자료 구조를 가진 리두 로그를 가지고 있으며, 비정상 종료가 발생하면 리두 로그의 내용을 이용해 데이터 파일을 다시 서버가 종료되기 직전의 상태로 복구한다. ACID도 중요하지만 성능도 중요하기 때문에 데이터 파일뿐만 아니라 리두 로그를 버퍼링할 수 있는 InnoDB 버퍼 풀이나 리두 로그를 버퍼링할 수 있는 로그 버퍼와 같은 자료 구조도 가지고 있다.

### 리두 로그 아카이빙

MySOL 8.0부터 추가된 기능으로 데이터 변경이 많아서 리두 로그가 덮어쓰인다고 하더라도 백업이 실패하지 않게 해준다.
서버에 유입되는 데이터 변경이 너무 많으면 리두 로그가 빠르게 증가하고, 새로 추가되는  내용을 복사하기도 전에 덮어쓰일 수도 있다. 이렇게 아직 복사하지 못한 리두 로그가 덮어쓰이면 백업툴이 리두 로그 엔트리를 복사할 수 없어서 백업은 실패하게 된다. 

### 리두 로그 활성화/비활성화

MySQL 8.0부터 수동으로 리두 로그를 비활성화 할 수 있게 됐다.

리두 로그는 항상 좋은게 아닌가? 그렇지 않다. 대용량 데이터를 적재할 때 리두 로그를 비활성화 하게 되면 성능적 이점을 얻을 수 있다. 이 방법은 서버가 비정상적으로 종료됐을 때 복구할 수 없다.

### 어댑티드 해시 인덱스

**인덱스**

테이블에 사용자가 생성해둔 B-Tree 인덱스를 의미한다. 

**어댑티드 해시 인덱스**

사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스.
어댑티브 해시 인덱스는 B-Tree 검색 시간을 줄여주기 위해 도입된 기능이다. 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고, 필요할 때마다 검색해서 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있다. CPU는 적은 일을 하지만 쿼리의 성능은 빨라진다.

`innodb_adaptive_hash_index` 변수를 이용해서 어댑티브 해시 인덱스 기능을 활성화/비활성화할 수 있다.

키값은 B-Tree 인덱스의 고유번호와 실제 키 값을 조합하고 밸류는 버퍼 풀에 로딩된 데이터 페이지의 주소로 관리된다. B-Tree의 고유번호를 담는 이유는 어댑티브 해시 인덱스는 하나의 해시 인덱스에서 관리하기 때문이다.(8.0부턴 파티션 기능 제공)

도움이 되지 않는 경우

- 디스크 읽기가 많은 경우
- 특정 패턴의 쿼리가 많은 경우(조인이나 LIKE 패턴 검색)
- 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우

도움 되는 경우

- 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(디스크 읽기가 많지 않은 경우)
- 동등 조건 검색(동등비교와 IN 연산자)이 많은 경우
- 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우

어댑티브 해시 인덱스의 도움을 받을수록 테이블의 삭제 변경 작업에 치명적으로 다가오기 때문에 도움이 되는지 정확히 판단해야 한다. `SHOW ENGINE INNODB STATUS\G` 를 통해서 사용 비율을 볼 수 있다. 이 비율도 중요하지만 CPU, Memory 사용량 또한 중요하다.

### InnoDB, MyISAM, MEMORY 스토리지 엔진 비교

8.0버전부터 모든 영역을 InnoDB로 대체할 수 있어졌다. 또한 MyISAM과 MEMORY 스토리지 엔진은 InnoDB 스토리지 엔진을 따라갈 수 없다.
