# 4-2장 InnoDB 엔진 아키텍처

InnoDB는 MySQL엔진중 거의 유일하게 레코드 기반의 잠금을 제공한다. 그렇기 때문에 동시성 처리가 가능하고, 안정성과 성능이 뛰어나다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7d34ffea-452e-49c4-a4e1-64b4216a28be/Untitled.png)

위 사진은 InnoDB의 아키텍처인데, 특징을 살펴보도록 하자.

**PK에 의한 클러스터링**

InnoDB의 모든 테이블은 PK를 기준으로 클러스팅 되어 저장된다. 이게 무슨말이냐면, PK순서대로 디스크에 저장되며, **다른 인덱스들은 PK의 값을 논리적인 주소**로 사용한다.

PK가 클러스터링 인덱스이기 때문에 **레인지 스캔은 상당히 빠르게** 처리된다. 그렇기 때문에 실행계획에서 다른 인덱스보다 PK가 선택될 확률이 높다.

MyISAM은 클러스터링 키를 지원하지 않기 때문에 PK와 다른 인덱스는 구조적인 차이가 없다.

**FK 지원**

InnoDB에서 FK는 부모, 자식 테이블 모두 해당 칼럼에 인덱스를 생성하고, 변경시에 부모 자식 모두 체크한다. 이와 같은 특성으로 인해 여러 테이블로 전파되어 데드락을 야기하기도 한다.

수동으로 데이터 적재, 스키마 변경 작업등을 진행할때 실패할 수 있다. 이런 경우 `foreign_key_checks` 시스템 변수를 OFF로 변경하고 작업할 수 있다.(cascade무시)속성을 다시 ON 하기전에 부모, 자식 간의 일관성을 맞춰줘야 한다.

**MVCC(Multi Version Concurrency Controll)**

MVCC의 뜻은 하나의 레코드를 여러 버전으로 관리한다는 뜻이며, 가장 큰 목적은 lock 없이 읽관된 읽기이다. InnoDB는 언두 로그를 통해 이 기능을 제공한다. 

다음은 m_area가 서울에서 경기로 바뀌는 경우에 언두 로그의 변화를 나타낸 사진이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ee987156-4626-4049-9fa8-2ff3b6a3b716/Untitled.png)

커밋 여부와 상관없이 UPDATE 쿼리와 함께 버퍼풀은 변경되고, 기존 값은 언두 로그에 적재된다. 디스크는 보통 버퍼풀과 동일하지만 아닐 수 있다.

이때 **트랜잭션의 격리 수준에 따라서 어느 영역의 데이터**를 반환할지 결정된다.

커밋이 된다면 버퍼풀은 즉시 디스크에 반영되고, 트랜잭션이 사라지면 해당하는 언두 로그는 삭제한다.

**잠금 없는 일관된 읽기**

격리 수준이 SERIALIZABLE이 아닌 경우 SELECT 작업은 잠금을 대기하지 않고 바로 실행된다. 위의 사진과 같이 커밋되지 않은 데이터여도 언두 로그를 통해 잠금없이 SELECT 작업을 실행한다.

오랜시간 활성화된 트랜잭션으로 인해 언두 로그가 쌓여 서버가 느려지거나 문제가 발생하는경우도 있다. 따라서 트랜잭션이 시작되었다면 가능한 롤백/커밋을 해주자.

**자동 데드락 감지**
