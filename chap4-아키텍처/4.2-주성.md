## 4.2 InnoDB 스토리지 엔진 아키텍처
- 스토리지 엔진 중 거의 유일하게 **`레코드 기반의 잠금`** 을 제공
  
  - 높은 동시성 처리가 가능하고, 안정적이며 성능이 뛰어남

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/34ea4f75-0f63-4e67-9f73-a8d5baef00fd)

### 4.2.1 프라이머리 키에 의한 클러스터링
- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장됨
  
  - 키 값의 순서대로 디스크에 저장
    
  - 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용함
    
  - 프라이머리 키가 **`클러스터링 인덱스`** 이기 때문에, 기본적으로 쿼리 실행계획에서 다른 보조 인덱스에 비해 프라이머리 키의 비중이 높게 설정됨 (선택될 확률이 높다)
  
    - `빠른 레인지 스캔`
     
#### 클러스터링 인덱스란?
> 데이터를 특정 기준에 따라 물리적으로 그룹화하는 방식 (자세한건 8.8절에서)
      
- MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않음
  
  - MyISAM 테이블에서는 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없음

### 4.2.2 외래키 지원
- 외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능

  - MyISAM, MEMORY 테이블에서는 사용 X

- **`foreign_key_checks`** 시스템 변수를 `OFF`로 설정하여 일시적으로 외래 키 관계 체크 작업을 멈출 수 있음

  - 비활성화시 CASCADE 옵션도 무시함

  - 일관성을 맞춰준 다음 다시 외래키 체크 기능을 활성화 해야 함 (혹은 세션 종료)  

- 생각해볼 점

  - FK 사용하는 것이 좋은가?
  - 일관성을 안맞추고 활성화시 어떻게 되는가?

### 4.2.3 MVCC(Multi Version Concurrency Control)
- 일반적으로 **`레코드 레벨의 트랜잭션`** 을 지원하는 DBMS가 제공하는 기능
  
- MVCC의 가장 큰 **목적**은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있다

  - 언두 로그(Undo log)를 이용해 해당 기능을 구현  
  
- **`멀티 버전`** 의 뜻은 `하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다` 는 의미다
  
  - 예시
  
  ![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/9a37c2b2-461e-45e8-b969-ad5fe4e58182)
      
  ```sql
  UPDATE member SET m_area='경기' WHERE m_id=12;
  ```
      
  ![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/0c76e183-f667-4eee-8c7f-e587001a5e6e)
  
**아직 COMMIT이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 레코드를 조회하면 어디에 있는 데이터를 조회할까?**
  
- 시스템 변수(transaction_isolation)에 설정된 **격리 수준에 따라 다름**
  
  - 격리 수준이 READ_UNCOMMITTED라면, InnoDB 버퍼 풀이나 데이터 파일로부터 변경되지 않은 데이터를 읽어서 반환
    
  - 격리 수준이 READ_COMMITTED 이상이라면, 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환
  
  → 즉, 하나의 레코드에 대해 `2개의 버전이 유지`되고, 필요에 따라 어느 데이터가 보여지는지 여러 상황에 따라 달라진다!

  - 트랜잭션이 길어지면 2개의 버전 보다 많아질 수 있음. 언두 영역이 저장되는 시스템 테이블스페이스의 공간이 늘어나는 상황이 발생할 수 있으니 주의!   
  
- `COMMIT 실행 시`
  
  - InnoDB는 더이상의 변경작업 없이 지금의 상태를 영구적 데이터로 만듬
    
    - 커밋이 된다고해서, 언두 영역의 백업 데이터가 항상 바로 삭제되는 것은 아님
      
    - 이 언두 영역을 필요로 하는 트랜잭션이 더 없을 때 → 삭제
    
- `ROLLBACK 실행 시`
  
  - InnoDB는 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제

- 참고하면 좋은 영상 : https://youtu.be/wiVvVanI3p4

### 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/2465a467-8f48-47dd-b45d-42cd88c2a7bb)

- InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행함

- 잠금 없는 일관된 읽기

  - 격리 수준이 SERIALIZABLE이 아닌 경우, 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고 읽기 작업이 가능해짐
    
- long trasaction으로 문제가 발생할 수 있음
  
  - 일관된 읽기를 위해 언두 로그를 삭제하지 못하고, 계속 유지해야함
    
  - 장기간 활성 상태인 트랜잭션으로 인해 MySQL 서버가 느려지거나 문제가 발생할 때가 있을 수 있음
    
  - 따라서, 트랜잭션이 시작됐다면 가능한 한 빨리 커밋이나 롤백을 하는 것이 좋음!

### 4.2.5 자동 데드락 감지
- 내부적으로 잠금이 교착 상태(데드락)에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리함

**`데드락 감지 스레드`**
  
- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그 중 하나를 강제 종료
  
- 강제 종료할 트랜잭션 판단기준 → **`트랜잭션의 언두로그 양`**
  
  - 더 적게 가진 트랜잭션이 일반적으로 롤백 대상이 됨
    
  - 롤백을 해도 언두 처리를 해야 할 내용이 적다 → 강제 롤백으로 인한 MySQL 서버의 부하도 덜 유발함
          
- InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금은 볼 수가 없어서 데드락 감지가 불확실할 수가 있음
  
  - `innodb_table_locks` 시스템 변수를 활성화하면 **테이블 레벨의 잠금**까지 감지할 수 있음
      
**`데드락 감지 스레드 비활성화`**
  
- 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려짐
  
  - 데드락 감지 스레드가 느려지면 서비스 쿼리를 처리중인 스레드는 더는 작업을 진행하지 못하고 대기할 수 있음
    
- `innodb_deadlock_detect` 시스템 변수를 OFF로 설정하면 데드락 감지 스레드는 더는 작동하지 않음

  - 단, 데드락 감지 스레드가 작동하지 않는 경우 데드락 상황이 발생하면 무한정 대기함

    - `innodb_lock_wait_timeout` 활성화시 데드락 상황에서 일정 시간이 지나면 자동으로 요청 실패 및 에러 메시지 반환

    - 데드락 감지를 비활성화 했다면 해당 변수를 기본 값보다 낮은 값으로 변경해서 사용할 것을 권장
        
  - 만약 PK 또는 세컨더리 인덱스를 기반으로 매우 높은 동시성 처리를 요구하는 서비스가 있다면 innodb_deadlock_detect를 비활성화해보는 것도 좋다

### 4.2.6 자동화된 장애 복구
- InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 매커니즘이 탐재돼 있음

  - 이를 이용해, 서버 시작시 완료되지 못한 트랜잭션이나 디스크에 일부만 기록(Partial write)된 데이터 페이지, 등에 대한 일련의 복구 작업이 자동으로 진행됨

**`자동 복구`**
  
- InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행
  
- 만약 자동으로 복구될 수 없는 손상이 있다면, 자동 복구를 멈추고 MySQL 서버는 종료됨

**`자동 복구가 안되는 상황`**

- 자동 복구할 수 없다면, MySQL 서버의 설정 파일에 `innodb_force_recovery` 시스템 변수를 설정해서 MySQL 서버를 시작해야 함

  - 설정 값에 따라, InnoDB 스토리지 엔진이 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있음

    - 어떤 부분이 문제인지 안다면, 적절한 설정값으로 서버를 기동하면 된다

      - InnoDB의 로그 파일이 손상됐다면, 6으로 설정하고 MySQL 서버를 기동한다

      - InnoDB 테이블의 데이터 파일이 손상됐다면 1로 설정하고 MySQL 서버를 기동한다
        
    - 어떤 부분이 문제인지 알 수 없다면, 1부터 6까지 변경하면서 기동한다
      
      - 값이 계속 커질수록 심각한 상황이라, 데이터 손실 가능성이 커지고 복구 가능성은 적어짐

  - MySQL 서버가 기동되고 InnoDB 테이블이 인식되면

    - mysqldump를 이용해 데이터를 가능한 만큼 백업하고 그 데이터로 MySQL 서버의 DB와 테이블을 다시 생성하는 것이 좋음

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/2809a3b9-6b1a-44cb-a09d-3b67b376440a)

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/e5e04c6b-2d79-4971-849d-e375e16dbf9f)

- 위와 같이 진행했음에도 MySQL 서버가 시작되지 않으면 백업을 이용해 다시 구축하는 방법밖에 없음..

- 백업이 있다면, 마지막 백업으로 데이터베이스를 새로 구축하고, 바이너리 로그를 사용해 최대한 장애 시점까지 데이터를 복구할 수도 있다.

### 4.2.7 InnoDB 버퍼 풀
- **디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐싱해 두는 공간**

- **쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼의 역할**

#### 4.2.7.1 버퍼 풀의 크기 설정
- 운영체제와 각 클라이언트 스레드가 사용할 메모리를 충분히 고려해서 설정

- 커넥션이 많고 사용하는 테이블도 많은 경우, 레코드 버퍼 용도로 사용되는 메모리 공간이 많이 필요할 수도 있음

  > 레코드 버퍼: 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용되는 공간

  - 레코드 버퍼 공간은 별도로 설정할 수 없음

- MySQL 5.7버전부터 **`InnoDB 버퍼 풀의 크기를 동적으로 조절`** 할 수 있게 개선됨

  - 버퍼 풀의 크기를 작은 값으로 설정해 점진적으로 증가 시키는 방법이 최적

  - `innodb_buffer_pool_size` 시스템 변수로 크기 설정
    
    - 크리티컬한 변경이므로 가능하면 MySQL 사용이 상대적으로 적을 때 변경하는 것이 좋음

    - 버퍼 풀의 크기를 줄이는 작업은 서비스 영향도가 매우 크므로 되도록 하지 않는 것이 좋음

- InnoDB 버퍼 풀은 전통적으로 버퍼 풀 전체를 관리하는 잠금(세마포어)으로 인해 내부 잠금 경합을 많이 유발해왔음
    
    - 버퍼 풀을 여러개로 분리해서 관리할 수 있도록 개선됨

    - 각 버퍼 풀을 `버퍼 풀 인스턴스`라고 함
      
    - `innodb_buffer_pool_instances` 시스템 변수를 이용해서 분리

#### 4.2.7.1 버퍼 풀의 구조
- 버퍼 풀은 데이터를 **`페이지`** 크기(innodb_page_size)의 조각으로 나누어서 관리함

  - 버퍼 풀의 `페이지 크기 조각`을 관리하기 위해서 크게 3개의 자료 구조를 관리함
 
  **`LRU(Least Recently Used) 리스트`**
    - LRU(Old 서브리스트)와 MRU(Most Recently Used / New 서브리스트)리스트가 결합된 형태
    
    - `목적` : 디스크로부터 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼풀의 메모리에 유지해서 디스크 읽기를 최소화
  
  ![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/19e80c71-6942-4fda-9cc4-b4b97b877d8f)

  ![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/b7e49845-2ce7-4d81-93bb-968f89bdf756)


  **`플러시(Flush) 리스트`**
  - 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리
    
  - 일단 한번 데이터 변경이 가해진 데이터 페이지는 플러시 리스트에 관리되고 특정 시점이 되면 디스크로 기록돼야 함

  - 데이터가 변경되면 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영
     
    - 리두 로그가 디스크로 기록됐다고 해서 데이터 페이지가 디스크로 기록됐다는 것을 항상 보장하지는 않음
      
  - InnoDB 스토리지 엔진은 `체크포인트`를 발생시켜 디스크의 리두 로그와 데이터 페이지의 상태를 동기화함

    - `체크포인트`: MySQL 서버가 시작될 때 InnoDB 스토리지 엔진이 리두 로그의 어느 부분부터 복구를 실행해야 할지 판단하는 기준점을 만드는 역할

  **`프리(Free) 리스트`**
  - 비어있는 페이지들의 목록

  - 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용
 
#### 4.2.7.3 버퍼 풀과 리두 로그

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/1dfc9a10-42a2-4719-8dfe-6f61958afc58)

- 버퍼 풀의 데이터베이스 서버의 성능 향상을 위한 2가지 용도
  - **`데이터 캐시`**
    - 버퍼 풀의 메모리 공간을 늘리면 데이터 캐시 기능이 향상
        
  - **`쓰기 지연`**
    - 버퍼 풀은 **클린 페이지**와 **더티 페이지**를 가지고 있다.
      - `클린 페이지` : 디스크에서 읽은 상태로 전혀 변경되지 않음

      - `더티 페이지` : 변경된 데이터를 가짐
            
        - 더티 페이지는 버퍼 풀에 무한정 머무를 수 없음 → 언젠가 디스크로 기록돼야 함
        
    - 데이터의 변경이 계속 발생하면 리두 로그파일에 기록됐던 로그 엔트리는 어느 순간 다시 새로운 로그 엔트리로 덮어쓰이기 때문에,
      따라서 전체 리두 로그파일에서 재사용 가능한 공간과 당장 재사용 불가능한 공간을 구분해서 관리하는데,
      재사용 불가능한 공간을 **`활성 리두 로그 공간`**라고 한다

    - 리두 로그 파일의 공간은 계속 순환되어 재사용되는데, 매번 기록될 때마다 로그 포지션은 계속 증가하는데 이를 `LSN(Log Sequence Number)`이라 한다.

    - `체크포인트`에서 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화
      - 가장 최근 체크포인트 지점의 LSN이 활성 리두 로그 공간의 시작점이 됨
        
      - 체크 포인트가 발생하면 체크 포인트 LSN보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화돼야 함

#### 4.2.7.4 버퍼 풀 플러시(Buffer Pool Flush)
- 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 다음과 같은 2가지 플러시 기능을 백그라운드로 실행함
  - `플러시 리스트 플러시`
  - `LRU 리스트 플러시`

- MySQL 8.0 버전으로 업그레이드되면서 대부분의 서비스에서는 더티 페이지 플러시에서 예전과 같은 디스크 쓰기 폭증 현상은 발생하지 않는다
  
- 따라서, 서비스를 운영하면서 성능 문제가 발생하지 않는 상태라면 굳이 밑의 시스템 변수들을 조정할 필요는 없다

##### 4.2.7.4.1 `플러시 리스트 플러시`
- 리두 로그 공간의 재활용을 위해 주기적으로 플러시 리스트 플러시 함수를 호출
  - 함수가 호출되면, 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화 작업 수행
  - 얼마나 많은 더티 페이지를 한번에 디스크로 기록하느냐에 따라 사용자의 쿼리가 영향을 받음

- 이를 위해 InnoDB에서 시스템 변수를 제공

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/a0bc4bb5-04bb-4d3c-804e-cf4e1c1c3bf4)

- `innodb_page_cleaners`
    - 클리너 스레드의 개수
      
    - 클리너 스레드 : 더티 페이지를 디스크로 동기화하는 스레드
 
    - 가능하면 `innodb_buffer_pool_instances` 설정 값과 동일한 값으로 설정하자
      
- `innodb_max_dirty_pages_pct`
    - 더티 페이지 비율
      
    - 즉, 전체 버퍼풀이 가진 페이지의 몇 퍼센트까지 더티 페이지를 가질 수 있는가?(기본값 : 90%)
      
- `innodb_io_capacity`
    - 더티 페이지 쓰기를 실행하는 기준
      
    - 일반적인 상황에서 디스크가 적절히 처리할 수 있는 수준으로 값을 설정한다
      
- `innodb_io_capacity_max`
    - innodb_io_capacity와 달리, 디스크가 최대의 성능을 발휘할 때 어느 정도의 디스크 읽고 쓰기가 가능한지를 설정함
      
- `innodb_max_dirty_pages_pct_lwm`
    - 더티 페이지가 많으면 디스크 쓰기 폭발 현상이 발생할 수 있다
      
    - 일정 수준 이상의 더티 페이지가 발생하면 조금씩 더티 페이지를 디스크로 기록하게 한다
      
    - 급작스럽게 디스크 쓰기가 폭증하는 현상을 완화시키기 위함이다

- `innodb_adpative_flushing`
    - 어댑티브 플러시 기능 사용 여부

**`어댑티브 플러시`**
> innodb_io_capacity, innodb_io_capcity_max가 아니라, 리두 로그의 증가 속도를 분석해서 적절한 수준의 더티페이지가 버퍼풀에 유지될 수 있도록 한다
      
- `innodb_adpative_flushing_lwm`
    - 전체 리두 공간에서의 활성 리두 로그 공간이 해당 설정보다 미만이면 어댑티브 플러시가 작동하지 않는다
      
    - 활성 리두 로그 공간의 비율이 해당 설정 비율을 넘어서야 그 때부터 어댑티브 플러시 알고리즘이 작동된다
      
- i`nnodb_flus_neighbors`
    - 인접한 더티 페이지 함께 플러시하는 기능의 사용 여부
      
    - 더티 페이지를 디스크에 기록할 때 디스크에서 근접한 페이지 중에서 더티 페이지가 있다면 InnoDB 스토리지 엔진이 함께 묶어서 디스크로 기록하게 해준다

##### 4.2.7.4.2 `LRU 리스트 플러시`
- LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만들어야 함 → `LRU 리스트 플러시` 사용 

  - `innodb_lru_scan_depth`
    - LRU 리스트의 끝부분부터 시작해서 최대 해당 **설정 개수만큼의 페이지들을 스캔**
      
    - 이 때, 스캔하면서 더티 페이지는 디스크에 동기화하게 하며, 클린 페이지는 즉시 프리(Free)리스트로 페이지를 옮김
      
    - 버퍼풀 인스턴스별로 최대 해당 개수만큼 스캔하기 때문에, 실질적으로는 (innodb_buffer_pool_instances * innodb_lru_scan_depth) 만큼 수행

#### 4.2.7.5 버퍼풀 상태 백업 및 복구
- 버퍼풀과 쿼리의 성능은 밀접한 연관이 있음
  - 버퍼 풀에 쿼리들이 사용할 데이터가 준비되어 있음으로 디스크를 읽지 않아도 처리 되기 때문

- `버퍼풀 워밍업` : 디스크의 데이터가 버퍼 풀에 적재돼있는 상태
  
  - 버퍼풀이 잘 워밍업이 된 상태라면, 그렇지 않을 때보다 몇십 배로 쿼리 처리 속도가 좋아짐
  
- MySQL 5.6 버전부터는 **`버퍼 풀 덤프 및 적재 기능`**이 도입됨
  
- MySQL 서버를 재시작해야 하는 경우, MySQL 서버를 셧다운하기 전에 다음과 같이 `innodb_buffer_pool_dump_now` 시스템 변수를 이용해 현재 InnoDB 버퍼 풀의 상태를 백업할 수 있음

```sql
-- // MySQL 서버 셧다운 전에 버퍼 풀의 상태 백업
SET GLOBAL innodb_buffer_pool_dump_now=ON;

-- // MySQL 서버 재시작 후, 백업된 버퍼 풀의 상태 복구
SET GLOBAL innodb_buffer_pool_dump_load_now=ON;
```

- **`버퍼풀 백업`**
    - 데이터 디렉터리에 `ib_buffer_pool`이라는 이름의 파일로 생성된다
      - 버퍼 풀의 LRU 리스트에서 적재된 데이터 페이지의 메타 정보만 가져와서 저장
        - 빠르고 용량이 적음 
          
- **`버퍼풀 복구`**
    - 백업은 빠르지만 복구는 InnoDB 버퍼 풀의 크기에 따라 상당한 시간이 걸릴 수 있음
      - 진행 상황을 확인 가능함
        
      ```mysql
      -- // 버퍼풀 백업 진행사황
      SHOW STATUS LIKE 'Innodb_buffer_pool_dump_status'\G 
      ``` 
      
    - 버퍼풀 적재 작업에 너무 시간이 오래 걸려서 중간에 멈추고자 한다면 `innodb_buffer_bool_load_abort` 시스템 변수를 사용한다

      ```mysql
      SET GLOBAL innodb_buffer_pool_dump_load_abort =on; -- 백업 중지
      ```
      
    - 복구 시, 백업 파일이 반드시 셧다운하기 직전의 파일일 필요는 없음
      - `ib_buffer_pool` 파일에서 데이터 페이지의 목록을 가져온 후, 실제 존재하는 데이터 페이지면 InnoDB 버퍼 풀로 적재하지만 그렇지 않은 경우에는 무시함
    
- **`백업/복구 자동화`**
  - InnoDB 스토리지 엔진은, MySQL 서버가 셧다운되기 직전에 버퍼풀의 백업을 실행하고, 서버가 시작되면 자동으로 백업된 버퍼풀의 상태를 복구하는 기능을 제공함

  - `innodb_buffer_pool_dump_at_shutdown`, `innodb_buffer_pool_load_at_startup` 설정을 설정 파일에 넣어두면 된다



#### 4.2.7.5 버퍼풀의 적재 내용 확인
- 버퍼 풀이 큰 경우, 버퍼풀의 메모리에 존재하는 테이블을 조회하는 것이 상당히 큰 부하를 일으켜 서비스 쿼리가 느려지는 문제가 있었음

- 8.0에서는 이러한 문제점을 해결하기 위해 information_schema db에 i`nnodb_cached_indexes` 테이블을 새롭게 추가함
  - 테이블 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재돼 있는지 확인할 수 있음

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/578cd788-6ec7-4683-aa39-a9bee2f33da1)

### 4.2.8 Double Write Buffer
- 리두 로그는 리두 로그 공간의 낭비를 막기 위해 **페이지의 변경된 내용만 기록**
  - 하드웨어의 오작동이나 시스템 비정상 종료를 하게 되어 파셜 페이지가 발생하면, 그 페이지의 내용은 복구할 수 없을 수도 있다

`파셜 페이지(Partial-page)` 혹은 `톤 페이지(Torn-page)` 
> 더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제

- 이 같은 문제를 막기위해서, InnoDB 스토리지 엔진에서는 Double-Write 기법을 이용함

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/0ee3df91-3af7-4246-a672-13dda16addb9)

**`예시`** 
- A~E까지의 더티 페이지를 디스크로 플러시한다고 해보자

1. InnoDB 스토리지 엔진은 실제 데이터 파일에 변경 내용을 기록하기 전에,
   A~E까지의 더티 페이지를 우선 묶어서 한 번의 디스크 쓰기로 시스템 테이블스페이스의 DoubleWrite 버퍼에 기록한다

2. InnoDB 스토리지 엔진은 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기를 실행한다

- DoubleWrite 버퍼의 내용은 실제 데이터 파일의 쓰기가 중간에 실패할 때만 원래의 목적으로 사용함
  
- 만약 기록되는 도중에 운영체제가 비정상적으로 종료됐다면
  
    - InnoDB 스토리지 엔진은 재시작될 때 항상 DoubleWrite 버퍼의 내용과 데이터 파일의 페이지들을 모두 비교한다
      
    - 그리고 다른 내용을 담고 있는 페이지가 있으면 DoubleWrite 버퍼의 내용을 데이터 파일의 페이지로 복사한다
    
- `innodb_doublewrite` 시스템 변수로 DoubleWrite기능을 사용할지 결정

### 4.2.9 언두 로그
- InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업함
  - 이렇게 백업된 데이터를 언두 로그(Undo Log)라고 함

- **`언두 로그의 사용`**
  
![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/b981cd9c-c831-4728-99c6-153a43ea88a0)

- 관리 비용이 크고, 문제점이 있음

#### 4.2.9.1 언두 로그 레코드 모니터링

- 언두 영역은 DML로 데이터를 변경했을 때 변경되기 전의 데이터(이전 데이터)를 보관하는 곳

- 언두 로그의 데이터는 크게 두 가지 용도로 사용됨
  - 트랜잭션의 롤백 대비용
    
  - 트랜잭션의 격리 수준을 유지하며 높은 동시성 제공

- 5.5 이전 버전에서는 한 번 증가한 언두 로그 공간은 새로 구축하지 않는 한다시 줄어들지 않았음
  - 1억 건 레코드가 저장된 100GB 크기 테이블을 DELETE로 삭제한다고 가정
    
  - 서버는 이 테이블에서 레코드를 한 건 삭제하고 언두 로그에 삭제되기 전 값을 저장
    
  - 이렇게 1억 건의 레코드가 있는 테이블에서는 삭제되지만 언두 로그로 복사되어야 함
    
  - 즉, 테이블 크기만큼 언두 로그 공간 사용량이 늘어나 결국 언두 로그 공간이 100GB가 되는 것

- 5.7과 8.0 으로 업그레이드되면서 언두 로그 공간의 문제점은 완전히 해결됨
  - 8.0에서는 언두 로그를 돌아가면서 순차적으로 사용해 디스크 공간을 줄이는 것이 가능
    
  - 때로는 MySQL 서버가 필요한 시점에 사용 공간을 자동으로 줄여주기도 함

- 단, 대용량 데이터를 처리하는 트랜잭션뿐 아니라 **`트랜잭션이 오랜 시간 실행될 때`**도 언두 로그의 양은 급격히 증가할 수 있음

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/6214b7ca-ca53-411c-a12a-596fd9ed58f2)

- 위 그림에서 B, C 트랜잭션은 완료됐지만 A는 완료되지 않음
  
- B,C는 UPDATE DELETE를 실행했기에 변경 이전의 데이터를 언두 로그에 백업했을 것
  
- 하지만 먼저 시작된 A 트랜잭션이 아직 활성 상태이므로, B,C 완료 여부와 관계 없이 B,C 트랜잭션이 만들어낸 언두 로그는 삭제되지 않음
  
- 즉, 활성 상태의 트랜잭션이 장시간 유지되면, 언두 로그에는 더 레코드가 쌓이게 된다

- 빈번하게 변경된 레코드를 조회하는 쿼리가 실행되면 InnoDB는 **언두 로그의 이력을 필요한 만큼 스캔해야만 필요한 레코드를 찾을 수 있기에**, 쿼리 성능이 떨어짐

- 따라서, 공간 문제는 해결되었으나 여전히 활성상태의 트랜잭션이 장시간 유지되는 것은 성능상 좋지 않다

- 그래서 언두 로그가 얼마나 증가했는지는 항상 모니터링 하는 것이 좋다. 

**`언두 로그 건수 확인`**
```mysql
-- // mysql 서버의 모든 버전에서 사용가능한 명령러
SHOW ENGINE INNODB STATUS \g

-- //MySQL 8.0에서 사용 가능한 명령
SELECT count
FROM information_schema.innodb_metrics
WHERE SUBSYSTEM='transaction' AND NAME='trx_rseg_history_len'
```

#### 4.2.9.2 언두 테이블스페이스 관리
- **`언두 테이블스페이스`** : 언두 로그가 저장되는 공간
  
- `버전별 변화`
  - 5.6 이전에는 언두 로그가 모두 시스템 테이블스페이스에 저장되었음
    
  - 시스템 테이블스페이스의 언두 로그는 MySQL 서버가 초기화될 때 생성되기 때문에 확장의 한계가 있었다
    
  - 5.6버전에서 `innodb_undo_tablespaces` 시스템 변수 도입
      - 2보다 큰 값을 설정하면 InnoDB 스토리지 엔진은 더이상 언두 로그를 시스템 테이블스페이스에 저장하지 않고 별도의 언두 로그 파일을 사용
      
      - 8.0(8.0.14)에서는 deprecated → 항상 별도 로그 파일에 기록됨

**`언두 테이블 스페이스의 구성`**

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/b6f9d63f-3def-4e6c-82d2-2d1bd1631599)

- 하나의 언두 테이블스페이스는 1개 이상 128개 이하의 롤백 세그먼트를 가짐
  
- 롤백 세그먼트는 1개 이상의 언두 슬롯(Undo Slot)을 가짐

- 하나의 롤백 세그먼트는 InnoDB의 페이지 크기를 16바이트로 나눈 값의 개수만큼의 언두 슬롯을 가짐

  - 예를 들어, InnoDB의 페이지 크기가 16KB
    
  - 하나의 롤백 세그먼트는 1024개의 언두 슬롯을 갖게 됨

- 하나의 트랜잭션이 필요로 하는 언두 슬롯의 개수는 트랜잭션이 실행하는 **DML 특성에 따라 최대 4개까지 언두 슬롯을 사용**함

- 일반적으로는 트랜잭션이 임시 테이블을 사용하지 않으므로 하나의 트랜잭션은 대략 2개 정도의 언두 슬롯을 필요로 한다고 가정하면 됨

  ```text
  최대 동시 트랜잭션 수 = (InnoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이스 개수)
  ```

- 8.0 이전까지는 한번 생성된 언두 로그는 변경이 허용되지 않고 정적으로 사용됨

  - 8.0 버전부터는 CREATE UNDO TABLESPACE나 DROP TABLESPACE 같은 명령으로 **새로운 언두 테이블 스페이스를 동적으로 추가하고 삭제할 수 있게 개선**

- 언두 테이블스페이스 공간을 필요한 만큼만 남기도 불필요하거나 과도하게 할당된 공간을 OS로 반납하는 것을 **`Undo tablespace truncate`**라고 한다

- `Truncate`에는 두 가지 방법이 있다(8.0부터 지원)

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/4655e104-d9f9-4b69-8c3f-cddc719e705a)

**`자동 모드`**
- 트랜잭션이 데이터를 변경하면 이전 버전의 데이터를 언두 로그로 기록
  
- 트랜잭션이 커밋되면 더 이상 언두 로그에 복사된 이전 값은 불필요해짐
  
- InnoDB 스토리지 엔진의 **퍼지 스레드**는 주기적으로 깨어나서 언두 로그 공간에서 불필요해진 언두 로그를 삭제하는 작업 실행
 - 이 작업을 **Undo Purge**라고 함

- 이 작업을 수행하게 하려면 `innodb_undo_log_truncate` 시스템 변수를 ON으로 설정하면 된다.

**`수동 모드`**
- 수동 모드는 언두 테이블스페이스가 최소 3개 이상은 돼야 작동

- 언두 테이블 스페이스가 비활성화 됨

1. `innodb_undo_log_truncate` 시스템 변수가 OFF로 설정된 경우

2. 예상보다 자동 모드로 언두 테이블스페이스의 공간 반납이 부진한 경우

- 그 다음으로 퍼지 스레드는 비활성 상태의 언두 테이블 스페이스를 찾아 불필요한 공간을 잘라내고, OS로 반납

- 반납이 완료되면 언두 테이블스페이스를 다시 활성화

```sql
-- // 언두 테이블스페이스 비활성화
ALTER UNDO TABLESPACE tablespace_name SET INACTIVE;

-- // 퍼지 스레드에 의해 언두 테이블스페이스 공간이 반납되면 다시 활성화
ALTER UNDO TABLESPACE tablespace_name SET ACTIVE;
```

### 4.2.10 체인지 버퍼
- 디스크로부터 읽어와서 업데이트를 해야하는 경우에, 이를 즉시 실행하지 않기 위해 임시로 저장하기 위한 공간
  - 레코드가 INSERT/UPDATE될 때, 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요함
    
  - 테이블에 인덱스가 많다면 상당히 많은 자원을 소모하게 됨
  
  - 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행
    
  - 그렇지 않다면, 디스크로부터 읽어와서 업데이트를 해야하는데, 이를 즉시 실행하지 않고 **`체인지 버퍼`** 라는 임시 공간에 저장함

- 유니크 인덱스의 경우 사용 X

**`체인지 버퍼 머지 스레드`** 
- 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 **백그라운드 스레드**에 의해 병합되는데, 이 스레드를 **`체인지 버퍼 머지 스레드`**라고 한다.

- `5.5 이전`
  - INSERT 작업에 대해서만 이러한 버퍼링이 가능했음
    - 이를 인서트 버퍼라고 함
      
  - 별도 시스템 변수 설정 없이 기본적으로 기능이 활성화 되었음
    
- `5.5 이상 ~ 8.0 이후`
  - DML로 인해 키를 추가하거나 삭제하는 작업에 대해서도 버퍼링이 될 수 있게 개선됨
    
  - `innodb_change_buffering`이라는 시스템 변수가 새로 도입되었음

  ![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/8890e0e9-2724-4809-bf5a-7bf1dc273124)

  - 체인지 버퍼는 기본적으로 InnoDB 버퍼 풀로 설정된 메모리 공간의 25%까지 사용할 수 있게 설정되어 있음(필요하다면, 50%까지 사용 가능)

### 4.2.11 리두 로그 및 로그 버퍼
- MySQL 서버가 비정상적으로 종료됐을 때, `데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치`
  - 트랜잭션 속성(ACID) 중 Durable(지속성) 과 밀접한 연관
  
- MySQL 서버를 포함한 대부분 데이터베이스 서버는 데이터 변경 내용을 **`로그로 먼저 기록`**함
  - 변경된 데이터를 데이터 파일에 기록하려면 상대적으로 큰 비용이 필요하다

  - 성능 저하를 막기 위해 데이터베이스 서버는 쓰기 비용이 낮은 자료 구조를 가진 리두 로그를 가지고 있다

  - 비정상 종료가 발생하면 리두 로그의 내용을 이용해 **데이터 파일을 다시 서버가 종료되기 직전의 상태로 복구**한다

- 리두 로그를 버퍼링할 수 있는 로그 버퍼와 같은 자료구조도 가짐

MySQL 서버가 비정상적으로 종료시 가질 수 있는 일관되지 않은 데이터 파일

1. **커밋됐지만 데이터 파일에 기록되지 않은 데이터**

2. **롤백됐지만 데이터 파일에 이미 기록된 데이터**

- 1의 경우, 리두 로그에 저장된 데이터를 데이터 파일에 복사하면 됨

- 2의 경우, 언두 로그의 내용을 가져와 복사하면 됨
  - 리두 로그를 통해 변경이 어떤 상태였는지 알아야 함 

- 리두 로그는 트랜잭션이 커밋되면 즉시 디스크로 기록되도록 시스템 변수를 설정하는 것을 권장
  - 서버가 비정상적으로 종료됐을 때, 직전까지의 트랜잭션 커밋 내용이 리두 로그에 기록될 수 있음
    - 이 리두 로그를 이용해 장애 직전 시점까지의 복구가 가능해짐
      
  - `innodb_flush_log_at_trx_commit` : 리두 로그를 어느 주기로 디스크에 동기화할지를 결정하는 시스템 변수

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/3ac0fba8-4aad-4d84-8ccb-ac2f3437937a)

#### 4.2.11.1 리두 로그 아카이빙
- 8.0부터 InnoDB 스토리지 엔진의 리두 로그를 아카이빙할 수 있는 기능이 추가되었음
  - 데이터 변경이 많아서 리두 로그가 덮어쓰인다고 하더라도 백업이 실패하지 않게 해줌
    - 엔터프라이즈 백업, Xtrabackup 툴은 데이터 변경이 매우 많을 때, 리두 로그 내용을 복사하기도 전에 덮어씌워 지는 경우가 있었음

**`사용법`**
- 저장될 디렉터리를 `innodb_redo_log_archive_dirs` 시스템 변수에 설정해야 함
  
- MySQL 서버를 실행하는 유저만 접근이 가능해야 함
  
- `innodb_redo_log_archive_start` UDF(사용자 정의 함수) 실행
  
- UDF를 실행한 세션이 계속 연결이 끊어지지 않고 유지되어야 리두 로그 아카이빙이 계속 실행됨
  
- `innodb_redo_log_archive_stop` UDF를 실행하기 전 끊어지면 아카이빙을 멈추고 파일을 자동 삭제함

#### 4.2.11.2 리두 로그 활성화 및 비활성화

- 8.0부터 수동으로 리두 로그를 활성화/비활성화 할 수 있게 되었음
  - **데이터를 복구하거나 대용량 데이터를 한번에 적재하는 경우**, 리두 로그를 비활성화해서 `적재 시간을 단축`시킬 수 있음

```mysql
ALTER INSTANCE DISABLE INNODB REDO_LOG;

-- 리두 로그를 비활성화한 후 대량 데이터 적재를 실행
LOAD DATA ...
  
ALTER INSTANCE ENABLE INNODB REDO_LOG;
```

- 리두 로그 활성 상태 확인
  
```mysql
SHOW GLOBAL STATUS LIKE 'Innodb_redo_log_enabled';
```

##### 주의점
- MySQL 서버는 재시작 할 때 자신이 가진 리두 로그에서 데이터 파일에 기록되지 못한 데이터가 있는지 검사하게 됨

- 근데, 위 명령어로 리두 로그가 비활성화 된 상태에서 비정상적 종료가 되면 리두 로그를 이용한 복구가 불가능하게 됨
- 이 경우, innodb_force_recovery 시스템 변수를 6으로 설정 후 다시 시작해야 함

### 4.2.12 어댑티브 해시 인덱스
- InnoDB 스토리지 엔진에서 **`사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스`**
  - `innodb_adaptive_hash_index` 변수로 활성화 여부 설정

- 어댑티브 해시 인덱스는 B-Tree **검색 시간을 줄여주기 위해** 도입된 기능
  - 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만듬
    
  - 필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있음

- 해시 인덱스는 **`인덱스 키 값`** + **인덱스 키 값이 저장된 `데이터 페이지 주소`**의 쌍으로 관리된다
  - **`인덱스 키 값`** : **B-Tree 인덱스의 고유번호(Id)** + **B-Tree 인덱스의 실제 키 값** (조합)
    
  - **`데이터 페이지 주소`** : 실제 키 값이 저장된 **데이터 페이지의 메모리 주소**
    - **InnoDB 버퍼풀에 로딩된 페이지의 주소**
      
    - 따라서, 어댑티브 해시 인덱스는 버퍼 풀에 올려진 데이터 페이지에 대해서만 관리된다
      
    - 버퍼 풀에서 해당 데이터 페이지가 없어지면, 어댑티브 해시 인덱스에서도 해당 페이지의 정보는 사라진다

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/c19c272d-c49b-4216-9b4e-42373efe154b)

- 해시 인덱스의 경합과 파티셔닝
  - 예전 버전까지는 어댑티브 해시 인덱스는 하나의 메모리 객체인 이유로 어댑티브 해시 인덱스의 경합이 상당히 심했다
    
  - MySQL 8.0부터는 내부 잠금 경합을 줄이기 위해 파티션 기능을 제공한다
    
  - innodb_adaptive_hash_index_parts 시스템 변수 : 파티션 개수 변경 (기본값 8개)
      
**`어댑티브 해시 인덱스가 도움이 되는가?`**
- 도움이 될지 아닐지 판단하기 쉽지 않음
  - 실제로는 어댑티브 해시 인덱스를 의도적으로 비활성화하는 경우도 많다
      
  - **`성능 향상에 크게 도움되지 않는 경우`**
    - 디스크 읽기가 많은 경우
      
    - 특정 패턴의 쿼리가 많은 경우(조인이나 LIKE 패턴 검색)
      
    - 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우
        
  - **`성능 향상에 도움이 되는 경우`**
    - 디스크 읽기가 많지 않은 경우
      
    - 동등 조건 검색이 많은 경우
      
    - 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우

### 4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교
- 5.5 ~ 8.0 이전
  - InnoDB 스토리지 엔진이 기본 스토리지 엔진
    
  - MySQL 서버의 시스템 테이블은 여전히 MyISAM 테이블을 사용
    
  - 전문 검색이나 공간 좌표 검색 기능은 MyISAM 테이블에서만 지원
      
- 8.0 이후
  - MySQL 서버의 모든 시스템 테이블이 InnoDB 스토리지 엔진으로 교체
    
  - 모든 기능을 InnoDB 스토리지 엔진만으로 구현 가능

- 5.7 이전
  - MEMORY 스토리지 엔진이 내부 임시 테이블의 용도로 사용
    - 가변 길이 타입의 컬럼을 지원하지 않는다는 문제점 존재

`결론`: MyISAM, MEMORY를 굳이 사용할 장점은 없으며, InnoDB를 사용하는 것이 좋다.

---
Q. 데이터가 저장되는 흐름을 이야기해주세요.
