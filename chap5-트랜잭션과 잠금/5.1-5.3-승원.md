# 5-1 ~ 5.3 장

# 5.1 트랜잭션

트랜잭션은 하나의 작업 셋이 100% 적용되거나 ROLLBACK되어야 함을 보장해주는 것이다. 트랜잭션을 지원하는 InnoDB와 지원하지 않는 MyISAM의 처리방식을 살펴보자

### MySQL에서의 트랜잭션

위에서 말했지만, MyISAM은 트랜잭션을 지원하지 하지 않는다. 따라서 쿼리 실행중 실패한 쿼리가 있더라도 다른 쿼리들은 반영이 된다. 반면에 InnoDB는 트랜잭션을 지원하기 때문에 실패에 대한 처리작업을 하지 않아도 된다.

**트랜잭션 범위**

트랜잭션의 범위가 큰 경우 DBMS에 부하를 주거나 위험한 상태에 빠지게 할 수 있기 때문에 범위를 최소의 코드에만 적용하는 것이 좋다. 

- DB에 영향을 주지 않는 경우
- 원격 서버와 통신하는 경우
- 작업 성격이 다른 경우

### MySQL엔진 락

스토리지 엔진을 제외한 나머지 영역의 락을 뜻한다. MySQL엔진 락은 스토리지엔진에 영향을 끼치지만, 스토리지 엔진의 락은 다른 스토리지 엔진에 영향을 끼치지 않는다.

테이블 데이터 동기화를 위한 락과 테이블 구조를 잠구는 메타데이터 락, 네임드 락이라는 기능을 제공한다.

**글로벌 락**

`FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있으며, MySQL에서 가장 범위가 크다. 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 DDL, DML 문장을 대기상태로 만든다.

여러 DB에 존재하는 MyISAM이나 MEMORY 테이블에 대해 mysqldump로 백업받을때 사용한다. 

**백업 락**

InnoDB 엔진은 트랜잭션을 지원하기 때문에 가벼운 글로벌 락인 백업 락이 도입됐다. 글로벌 락과 비슷하지만, 일반적인 테이블의 데이터 변경이 가능하다. 

백업을 실행하는 도중에 스키마 변경이 실행되면 백업이 실패하기 때문에 락을 사용한다.

* `FLUSH TABLES WITH READ LOCK` 명령을 사용하면, 먼저 실행된 SQL과 트랜잭션이 완료된 후 잠금을 한다. 이때 실행된 락은 오랜 시간동안 지속되기 때문에 MySQL의 모든 테이블에 큰 영향을 미친다. 따라서 가극적으로 사용하지 않는 것이 좋다.

**테이블 락**

테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다. 명시적으로는 `LOCK TABLES 테이블이름 [ READ / WRITE ]`  명령으로 특정 테 이블의 락을 획득할 수 있다. 

테이블 락은 MyISAM뿐 아니라 InnoDB 엔진을 사용하는 테이블도 동일하게 설정할 수 있다. 명시적으로 획득한 락은 UNLOCK TABLES 명령으로 잠금을 해제 할 수 있다. 명시적인 테이블 락은 글로벌 락과 동일하게 작업에 상당한 영향을 미치기 때문에 사용할 필요가 거의 없다.

묵시적인 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다. MySOL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후, 즉시 잠금을 해제하는 형태로 사용된다. 즉, 묵시적인 테이블 락은 쿼리가 실행되는 동안 자동으로 획득됐다가 쿼리가 완료되면 자동으로 해제된다.

InnoDB에선 레코드 기반 잠금을 지원하기 때문에 데이터 변경에는 사용되지 않고, DDL에 사용된다.

**네임드 락**

테이블, 레코드, DB객체가 아닌 단순히 사용자가 지정한 문자열에 대해 획득 및 반납하는 락이다. `GET_LOCK()` 함수를 사용해 임의의 문자열에 대해 잠금을 설정한다.  

복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용할 수 있다. 배치 프로그램처럼 한번에 많은 레코드를 변경하는 쿼리는 데드락의 원이이 되곤 하는데, 여러 방법이 있지만, 동일 데이터를 변경하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 간단히 해결이 가능하다.

MySQL 8.0 부터 네임드 락을 중첩해서 사용할 수 있고, 한번에 해제할 수 있어졌다.

**메타데이터 락**

DB 객체(테이블, 뷰 등)의 이름이나 구조를 변경할 때 획득한다. 메타데이터 락은 명시적으로 획득/해제 할 수 없고, `RENAME TABLE before TO after` 처럼 이름을 변경할 때 사용한다. 이런경우 before, after 모두 잠긴다.

때로는 메타에디어 락과 InnoDB 트랜잭션을 동시에 사용해야 하는 경우도 있다. 예를들어 로그 테이블을 변경하려 할때 DDL은 싱글 스레드로 작동하기 때문에 상당히 많은 시간이 걸린다. 따라서 새로운 구조의 테이블을 생성하고 id 범위별로 나눠서 여러 개의 스레드로 빠르게 복사한다. 이렇게 하고 남은 데이터는 테이블 잠금을 통해 복사한다.

# InnoDB 스토리지 엔진 락

InnoDB는 레코드 기반의 락 방식으로 훨씬 뛰어난 동시성 처리를 제공할 수 있다. 하지만 이원화된 락 처리 탓에 InnoDB 스토리지 엔진에서 사용되는 락에 대한 정보는 MySQL 명령을 이용해 접근하기가 상당히 까다롭다. 예전 버전에서는 InnoDB의 락 정보를 진단할 수 있는 도구는 Iock monitor 테이블을 생성해서 락 정보를 덤프하는 방법과 `SHOW ENGINE INNODE STATUS` 명령이 전부였다.
최근 버전은 InnoDB의 트랜잭션과 락, 그리고 대기 중인 트랜잭션의 목록을 조회할 수 있다. information_schema에 존재하는 INNODE_TRX, INNODB_LOCKS, INNODB_ LOCK_WAITS라는 테이블을 조인해서 조회하면 락을 소유하고 있는 트랜잭션, 점유시간을 알 수 있다. 그리고 Performance Schema를 이용해 InnoDB 내부의 락에 대한 모니터링 방법도 추가됐다.

### InnoDB 스토리지 락

레코드 락이 페이지 또는 테이블 락으로 레벨업 되는 경우는 없다. 일단 DBMS와 다르게 InnoDB는 레코드 간격을 잠그는 갭 락이라는 것이 존재한다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/2b25b7d9-824d-42c1-addd-c188417a13ba)

**레코드 락**

레코드 자체만 잠구는 것을 뜻한다. 중요한 점은 레코드 자체가 아니라 인덱스의 레코드를 잠근다. 인덱스가 하나도 없는 경우 내부적으로 생성된 클러스터 인덱스를 잠군다.

보조 인덱스를 이용한 변경 작업은 대부분 넥스트 키 락 또는 갭 락을 사용하지만 PK, UK에 의한 변경 작업에서는 갭에 대해 잠그지 않고 레코드 자체에 락을 건다.

**갭 락**

레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격을 잠그는 것을 의미한다. 갭 락의 역할은 레코드와 레코드 사이에 새로운 레코드가 생기는 것을 제어하는 역할이다.

**넥스트 키 락**

레코드 락과 갭 락을 합쳐 놓은 형태의 락이다. 

STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEATABLE READ 격리 수준을 사용해야 한다. 또한 innodb_locks_unsafe_for_binlog 시스템 변수가 비활성화되면(0으로 설정) 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸린다. 

InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다. 

넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다. 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.

* STATEMENT 포맷의 바이너리 로그란 실행된 SQL문을 그대로 바이너리 로그에 저장하는 방식을 뜻한다. 다수에 데이터가 수정된 경우에도 쿼리만 기록하면 되기 때문에 적은 용량의 로그파일을 관리한다는 장점이 있다.

* ROW 포맷의 로그는 데이터를 로깅하기 때문에 비교적 더 적은 락이 생기고, 트랜잭션을 사용할 수 있다. 레플리카 서버와 안전하게 일관성을 유지할 수 있다.

**자동 증가 락**

MySQL에선 자동 증가하는 숫자 값을 추출하기 위해 AUTO_INCREMENT라는 칼럼 속성을 제공한다. AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우 내부적으로 자동 증가 락이라는 테이블 수준의 락을 사용한다.

트랜잭션과 관계없이 INSERT나 REPLACE 문장에서 AUTO_INCREMENT값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다. 테이블에 단 하나만 존재하기 때문에 두개 이상의 INSERT 쿼리가 동시에 실행되면 하나의 쿼리는 대기하게 된다.

명시적으로 획득/해제 할 수 없으며, 아주 짧은 시간 사용되기 때문에 문제가 되지 않는다. MySQL 5.1 부터 자동 증가 락 방법을 변경할 수 있다.

- innodb_autoinc_lock_mode=0
MySQL 5.0과 동일한 잠금 방식으로 모든 INSERT 문장은 자동 증가 락을 사용한다.
- innodb_autoinc_lock_mode=1
여러건을 INSERT 하는 경우, 서버가 INSERT 되는 레코드의 건수를 정확히 예측할 수 있을 때 자동 증가 락을 사용하지 않고, 훨씬 가볍고 빠른 래치를 이용해 처리한다.
건수를 예측할 수 없는 경우 0번 방식을 사용한다. 대량의 INSERT가 실행될 때 여러개의 자동 증가 값을 한 번에 받아서 INSERT 하는 방법이다. 자동 증가 값이 남는 경우 폐기된다.
- innodb_autoinc_lock_mode=2
절대 자동 증가 락을 사용하지 않고, 경량화된 래치 방법을 사용한다. 그렇기 때문에 연속된 자동 증가 값을 보장하지 않는다. STATEMENT 포맷의 바이너리 로그를 사용하는 복제에서는 소스 서버와 레플리카 서버의 자동 증가 값이 달라질 수도 있다.

### 인덱스와 락

변경해야 할 레코드를 찾기 위해 검색한 인덱스를 모두 락을 걸어야 한다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/3eb53fd1-10cf-4fcd-83b9-6c4a1e9904a4)

다음과 같이 클러스터드 인덱스와 first_name에 대한 인덱스만 있는 테이블이 있다. 

first_name이 Gerogi 인 사원이 253명이 있고 변경하려는 레코드는 1개이다. 이때 first_name에 대한 조건은 253개의 레코드, last_name은 인덱스가 없으므로 253개의 레코드가 모두 잠긴다. 

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/703ebf03-0239-4010-a652-ab9d1bdefc58)

만약 테이블에 인덱스가 하나도 없다면, 테이블을 풀 스캔하면서 테이블에 있는 모든 레코드를 잠그게 된다.

### 레코드 락 확인 및 해제

레코드 락은 테이블 락보다 조금 더 복잡하다. 레코드 락은 각각의 레코드에 걸리기 때문에 문제를 발견하기 어렵다.

예전 버전의 MySQL에선 레코드 락에 대한 메타정보를 제공하지 않았지만, 5.1 버전부터 잠금, 잠금 대기에 대한 조회가 가능하다. 잠금을 해제하려면 KILL 명령어를 사용해 MySQL 서버의 프로세스를 강제종료하면 된다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/992bdbe1-779f-4f0b-8c91-902698096e80)

다음과 같은 시나리오에서 락에 대한 정보를 조회해보자.

MySQL 5.1부터는 information_schema라는 DB에 INNODB_TRX라는 테이블과 INNODB_LOCKS,  INNODB_LOCK_WAITS라는 테이블을 통해 확인이 가능했다. 

MySQL 8.0 버전부터는 information_schema의 정보들은 조금씩 Deprecated 되고 있으며, 그 대신 performance_schema의 data_locks와 data_lock_waits 테이블로 대체되고 있다. 

performance_schema의 테이블을 이용해 잠금과 잠금 대기 순서를 확인하는 방법은 다음과 같다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/8607d802-1b9e-4c1e-9d0a-fd4d32742840)

17번 스레드는 UPDATE 명령이 실행되고 커밋되지 않은 상태, 18, 19는 기다리는 잠금대기 상태이다.

잠금 대기 순서를 조회하는 방법은 다음과 같다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/cb611b31-337f-4fc2-88d4-2fdfcf822280)

18, 19 스레드는 17과 18번 스레드를 기다리고 있다. `SELECT * FROM performance_schema.data_locks\G` 명령을 통해 상세 정보를 확인할 수 있다.
