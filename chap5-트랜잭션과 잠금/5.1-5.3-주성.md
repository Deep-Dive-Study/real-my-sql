# 05. 트랜잭션
- **`트랜잭션`**
  - 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위

  - 작업의 완전성을 보장해 주는 것(COMMIT, ROLLBACK)

  - 즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상(Partial update)이 발생하지 않게 만들어 주는 기능
  
- **`잠금(Lock)`**
  - 동시성을 제어하기 위한 기능

  - 여러 커넥션이 동시에 변경하는 것을 막고 순서대로 한 시점에서 하나의 커넥션만 변경할 수 있게 해주는 역할 

- **`트랜잭션 격리 수준(Isolation level)`**
  - 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨

#### ⚠️ 주의 
- 잠금과 트랜잭션을 혼동할 수 있음, 하지만 이는 명백히 다른 목적을 위한 것
  - 잠금은 동시성을 제어가 목적
  
  - 트랜잭션의 데이터 정합성을 보장하는 것이 목적

## 5.1 트랜잭션
- MyISAM 은 트랜잭션을 지원하지 않지만, InnoDB 는 트랜잭션을 지원

### 5.1.1 MySQL에서의 트랜잭션
- 트랜잭션을 지원하지 않을 경우 **부분 업데이트 (Partial Update)** 가 발생할 수 있음
  -  일부 쿼리가 실패하더라도 성공한 쿼리는 적용이 되어, 데이터 정합성을 맞추는 데 상당히 힘들어짐
  
- 애플리케이션 코드 레벨에서 **`보상 트랜잭션 (Compensating Transaction)`** (SAGA 패턴)을 직접 구현해야 하는 번거로움이 있음
  - 이로 인해 코드 복잡도도 증가하고, 핵심 트랜잭션 로직을 보기가 어려워짐
    
- 트랜잭션은 애플리케이션 개발에서 고민해야할 문제를 줄여주는 필수적인 DBMS 기능

## 5.1.2 주의사항
- 트랜잭션은 **반드시 필요한 최소의 코드** 에만 적용하는 것이 좋음
  - 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화되어 있는 범위를 최소화하자
  
![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/43defba4-17ac-4b06-92ab-3e09fefd4be4)

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/250e391e-b059-4cd3-87cb-0de3f0d37258)

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/ec258c31-b847-47bd-a596-c904ce9c1820)

1. 불필요한 작업 대기 - 트랜잭션에 포함시키지 마라
2. 네트워크 작업이 포함되어 있는 경우 - 반드시 트랜잭션에서 배제하라
3. 단순 조회의 작업인 경우 - 트랜잭션을 분리하라

**`개선된 절차`**

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/8abbec0e-c4a2-4722-8347-22a6aba58a22)

- 이런 실수로 인해 DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠지는 경우가 빈번히 발생함
  - 서비스 장애는 **평시에 발생하지 않는다** 대부분 **트래픽이 치솟을때** 발생함
  - 평시에는 문제가 없더라도, 1ms 하나하나가 쌓여 **장애 포인트** 가 될 수 있다는 생각을 가져야 함
  - **커넥션 고갈** 로 인한 장애 상황이 발생할 수 있음을 늘 인지해야 함

## 5.2 MySQL 엔진의 잠금
- MySQL 의 락은 **`스토리지 엔진`** 과 **`MySQL 엔진`** 레벨 두 가지로 분류
  - MySQL 엔진 레벨은 스토리지 엔진을 제외한 모든 부분이라 이해하면 됨
    
- **`MySQL 엔진 레벨의 락`** 은 **모든 스토리지 엔진** 에 영향을 미침
  
- **`스토리지 엔진 레벨의 락`** 은 **스토리지 엔진 간의 영향을 미치지 않음**

- MySQL 엔진에서는 테이블 데이터 동기화를 위한 **`테이블 락`** 이외에도 테이블의 구조를 잠그는 **`메타데이터 락`** 그리고 사용자의 필요에 맞게 사용할 수 있는 **`네임드 락`** 이라는 잠금 기능도 제공한다
  - **`테이블 락(Table Lock)`** : 테이블 데이터 동기화
  - **`메타데이터 락(Metadata Lock)`** : 테이블의 구조를 잠금
  - **`네임드 락(Named Lock)`** : 사용자의 필요에 맞게 사용하기 위함

### 5.2.1 글로벌 락
- 글로벌 락은 **`FLUSH TABLE WITH READ LOCK`** 명령으로 획득 가능
  - MySQL 에서 제공하는 락 중 범위가 가장 큼
    
- 특정 세션에서 **글로벌 락을 획득하면, 다른 세션에서 SELECT 를 제외한 대분의 DDL/DML 실행시 해당 락이 해제될 때 까지 대기해야 함**

- 글로벌 락은 **`MySQL 서버 전체`** 에 영향을 미침
  - 대상 **테이블/데이터베이스가 다르더라도 동일함**

#### `FLUSH TABLE WITH READ LOCK`
- FLUSH TABLE WITH READ LOCK 은 실행과 동시에 **MySQL 의 모든 테이블에 락을 건다**

- 해당 명령 실행전 Write 에 대한 락이 실행 되었다면, 해당 작업이 완료되기까지 대기해야함

- 또한 테이블에 읽기 잠금을 걸기 전 테이블을 플러시 해야 하기 때문에 해당 테이블에 대한 모든 실행 쿼리가 완료되어야 함
  - 때문에 심각한 경우 모든 테이블에 대한 INSERT UPDATE DELETE 쿼리가 실행되지 못하는 상태가 될 수 있음

- MyISAM/MEMORY `테이블 덤프`시 글로벌 락을 사용해야 함

- MySQL 8.0 부터는 InnoDB 가 기본 스토리지 엔진으로 채택 되며 Xtrabackup/Enterprise Backup 과 같은 툴들을 위한 `BACKUP LOCK(백업 락)`이 도입됨

```mysql
LOCK INSTANCE FOR BACKUP;
-- // 백업 실행
UNLOCK INSTANCE;
```

- 특정 세션에서 백업 락을 획득시, 모든 세션에서 테이블 스키마나 사용자 인증 정보를 변경할 수 없음
  - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경 삭제
    
  - REPAIR TABLE / OPTIMISE TABLE 명령
    
  - 사용자 관리 및 비밀번호 변경
    
- 하지만, **일반적인 테이블의 데이터 변경은 허용**
  
- 레플리카(Replica) 구성시, 주로 **레플리카 서버 에서 실행**
  - 글로벌 락 획득시 그만큼 복제 시간은 지연됨

- 6 ~ 7시간 동안 백업 진행 도중 DDL 문장 하나로 인해 시간이 날아갈 수도 있음
  - 이를 위해 백업 락이 존재함

- 백업 락은 정상적으로 복제는 실행 되지만, 백업 실패를 막기 위해 DDL 명령 실행시 복제를 일시 중지하는 역할을 수행

### 5.2.2 테이블 락
- 테이블 락은 **개별 테이블 단위** 로 설정되는 락이며, 명시적/묵시적 으로 특정 테이블의 락을 획득 가능

#### 명시적 테이블 락
- 명시적으로는 `LOCK TABLES table_name [ READ | WRITE ]` 명령으로 테이블 락을 획득 (MyISAM, InnoDB 동일)

- 명시적으로 획득한 테이블 락은 `UNLOCK TABLES` 명령으로 잠금을 반납함

- 명시적 테이블 락도 특별한 상황이 아니면 애플리케이션에서 사용할 필요가 거의 없음

- 글로벌 락과 마찬가지로 온라인 작업에 상당한 영향을 미치기 때문

#### 묵시적 테이블 락
- **MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생**
  - MySQL 서버가 **데이터가 변경되는 테이블에 잠금을 설정**하고 **데이터를 변경한 후, 즉시 잠금을 해제**하는 형태로 사용됨

- 즉, 묵시적 테이블 락은 쿼리가 실행되는 동안 자동으로 획득됐다가 쿼리가 완료된 후 자동 해제됨

- **하지만, InnoDB 테이블의 경우는 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공함**
  - 단순 데이터 변경 쿼리로 인해 묵시적 테이블 락이 설정되지는 않음

  - 정확히는 테이블 락이 설정되지만 대부분의 데이터 변경(DML) 쿼리는 무시, 스키마 변경(DDL) 만 영향을 줌

### 5.2.3 네임드 락
- 네임드 락은 **`GET_LOCK()`** 함수를 이용해 **임의의 문자열에 대해 잠금을 설정** 할 수 있음
  - 대상이 테이블이나 레코드 또는 AUTO_INCREMENT와 같은 DB 객체가 아님

- 네임드 락은 단순히 **`사용자가 지정한 문자열(String)`** 에 대해 획득하고 반납하는 잠금 
  - 자주 사용되지는 않음

- 요컨데, 데이터베이스 서버 1대에 5대의 웹 서버가 접속해서 서비스하는 상황에서

  - 5대의 웹 서버가 어떤 정보를 동기화해야 하는 요건처럼 여러 클라이언트가 **상호 동기화를 처리** 해야 할 때 네임드 락을 사용하면 쉽게 해결할 수 있음

```mysql
-- // "mylock"이라는 문자열에 대해 잠금을 획득한다.
-- // 이미 잠금을 사용 중이면 2초 동안만 대기한다. (2초 이후 자동 잠금 해제됨)
SELECT GET_LOCK('mylock', 2);

-- // "mylock"이라는 문자열에 대해 잠금이 설정돼 있는지 확인한다.
SELECT IS_FREE_LOCK('mylock');

-- // "mylock"이라는 문자열에 대해 획득했던 잠금을 반납(해제)한다.
SELECT RELEASE_LOCK('mylock');

-- // 3개 함수 모두 정상적으로 락을 획득하거나 해제한 경우엔 1을,
-- // 아니면 NULL이나 0을 반환한다.
```

- 또한 많은 레코드에 대해 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용할 수 있음

- `배치 프로그램`처럼 한꺼번에 많은 레코드를 변경하는 쿼리는 자주 데드락의 원인이 되곤 함!

  - **이러한 경우에는 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 아주 간단히 해결할 수 있음**

- MySQL 8.0부터 다음과 같이 **네임드 락 중첩 사용**이 가능해졌음
  - 현재 세션에서 획득한 **네임드 락을 한 번에 모두 해제하는 기능도 추가** 되었음

```mysql
-- // 동시에 모두 해제하고자 한다면 RELEASE_ALL_LOCKS() 함수 이용
SELECT RELEASE_ALL_LOCKS();
```

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/5204792b-91ba-4834-ba39-90ddd0678569)

### 5.2.4 메타데이터 락
- 메타데이터 락은 **데이터베이스 객체(대표적으로 테이블이나 뷰 등)의 이름/구조 변경** 시 획득하는 락
  - 명시적으로 획득하거나 해제할 수 없으며 `RENAME TABLE tab_a TO tab_b` 같이 테이블의 이름을 변경하는 경우에 자동으로 획득하는 잠금

  - `RENAME TABLE`의 경우 원본 이름과 변경될 이름 두 개 모두 **한꺼번에** 잠금을 설정함

```mysql
-- // 배치 프로그램에서 별도의 임시 테이블(rank_new)에 서비스용 랭킹 데이터를 생성

-- // 랭킹 배치가 완료되면 현재 서비스용 랭킹 테이블(rank)을 rank_backup으로 백업하고
-- // 새로 만들어진 랭킹 테이블을 서비스용으로 대체하고자 하는 경우
RENAME TABLE rank TO rank_backup, rank_new TO rank;
```

- 위와 같이 하나의 `RENAME_TABLE` 명령문에 두 개의 RENAME 작업을 한꺼번에 실행하면 실제 애플리케이션에서는 "Table not found rank"같은 상황을 발생시키지 않고 적용하는 것이 가능해짐

- 하지만, 해당 문장을 다음과 같이 2개로 나눠 실행하면 아주 짧은 시간이지만 rank 테이블이 존재하지 않는 순간이 생기며, 그 순간에 실행되는 쿼리는 "Table not found 'rank'" 오류를 발생시킴

```mysql
RENAME TABLE rank TO rank_backup;
RENAME TABLE rank_new TO rank;
```

- 때로는 메타데이터 잠금과  InnoDB 트랜잭션을 동시에 사용해야 하는 경우도 있음

해당 테이블을 웹 서버의 액세스 로그를 저장한다. (오로지 INSERT, UPDATE와 DELETE X)

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/5434536e-6db3-44a2-82ec-117678bd9019)

- 테이블 구조를 변경해야 할 요건이 발생했다고 가정

- MySQL 서버의 Online DDL이 실행되는 동안 누적된 버퍼의 크기 등 고민해야 할 문제가 많음

- 더 큰 문제는 MySQL 서버의 DDL은 단일 스레드로 작동하기 때문에 상당히 많은 시간이 소모될 것이라는 점

- 이때는 새로운 구조의 테이블을 생성하고 먼저 최근(1시간 직전 또는 하루 전)의 데이터까지는 프라이머리 키인 id 값을 범위별로 나눠서 여러 개의 스레드로 빠르게 복사한다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/be6d95fd-2b6b-45e2-882f-2e1e66da42e0)

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/157ff7c3-72a8-4d35-8cb1-5252e882d531)

- 그리고 나머지 데이터는 트랜잭션과 테이블 락, RENAME TABLE 명령으로 응용 프로그램의 중단 없이 실행하면 된다.
  - 남은 데이터를 복사하는 시간 동안은 테이블 락으로 인해 INSERT가 안됨

  - 따라서, 가능하면 미리 아주 최근 데이터까지 복사해 둬야 잠금 시간을 최소화할 수 있음

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/ce813dfe-f3f9-4992-92ec-b24e6f5044a5)

## 5.3 InnoDB 스토리지 엔진 잠금
- InnoDB 스토리지 엔진은 **`레코드 기반 락`** 을 제공
  - 때문에 MyISAM에 비해 뛰어난 동시성 처리를 제공할 수 있음

- 다만, 이원화된 잠금 처리 탓으로 예전 버전에서는 락에 대한 정보를 보기가 힘들었음
  
- 최신 버전에서는 `information_schama` 데이터베이스에 존재하는 테이블들을 활용해 락에 대한 정보를 획득할 수 있음
  - `INNODB_TRX`
  - `INNODB_LOCKS`
  - `INNODB_LOCK_WAITS`
    
- `Performance Schema` 를 이용한 내부 잠금에 대한 모니터링도 추가됨

### 5.3.1 InnoDB 스토리지 엔진 잠금
- 레코드 기반의 락을 제공하며, **상당히 작은 공간 으로 관리** 되기 때문에 **`락 에스컬레이션`**이 발생하지 않음
  - 즉, 레코드락 > 페이지락 > 테이블락 으로 레벨업 (**`락 에스컬레이션`**) 되는 경우가 없다
    
- 다른 DBMS 와는 다르게 레코드와 레코드 사이를 잠그는 **갭 락(GAP LOCK)** 이 존재함

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/fe238dcb-3bdd-4f91-8b7c-fd6bfa8b2383)

#### 5.3.1.1 레코드 락
- **레코드 자체 만을 잠그는 것**

- 다른 DBMS 와의 차이는 MySQL 은 **`인덱스의 레코드`** 를 잠금
  - 인덱스가 없더라도, 자동생성된 클러스터 인덱스를 사용함

- **PK 또는 유니크 인덱스에 대한 변경 작업** 에서는 레코드 락을 사용함
  - 보조 인덱스의 경우 넥스트 키락 혹은 갭 락을 이용함 

#### 5.3.1.2 갭 락
- 레코드와 인접한 레코드 사이의 간격을 잠그는 것
  - 레코드 사이에 새로운 레코드가 INSERT 되는 것을 제어함

- 넥스트 키 락의 일부로 자주 사용됨
    
#### 5.3.1.3 넥스트 키 락
- **`레코드 락과 갭 락을 합친 형태`**
  - STATEMENT 포맷의 바이너리 로그를 사용한다면 REPEATABLE READ 격리 레벨을 사용해야 함

  - `innodb_locks_unsafe_for_binlog` 시스템 변수가 비활성화되면 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸림

- 바이너리 로그에 기록되는 쿼리가 레플리카에 복제될 때 동일한 결과를 만들도록 보장하는 것이 목적

- 넥스트 키락/갭 락으로 인한 데드락이나 성능저하가 빈번하다는 점을 유의
  - 가능하면 바이너리 로그 포맷을 row 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋음

  - MySQL 8.0부터는 바이너리 로그의 기본 포맷이 row로 변경되었음

#### 5.3.1.4 자동 증가 락
- AUTO-INCREMENT 컬럼이 사용된 테이블에 대해 순서를 보장하기 위해 AUTO_INCREMENT 락 을 제공함
  - 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 값을 가져야 함

  - 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금을 사용(테이블 레벨의 락)
  
- 트랜잭션과 관계 없이 INSERT나 REPLACE에서 AUTO_INCREMENT 값을 가져오는 순간에만 락이 걸렸다 즉시 해제됨
  
- 테이블에 단 하나만 존재하며, 명시적으로 획득/해제 하는 방법은 없음
  
- 5.1 버전 부터는 `innodb_autoinc_lock_mode` 시스템 변수로 자동 방식 변경 가능

- innodb_autoinc_lock_mode=0
  - MySQL 5.0 까지 동일한 방식
  - 모든 INSERT 문장이 락을 사용

- innodb_autoinc_lock_mode=1
  - 단순 1건 또는 여러건 INSERT 시 MySQL 서버가 레코드 건수를 정확히 캐치할 수 있다면 락을 사용하지 않고 뮤텍스를 사용함 (래치)

  - 레코드 건수를 캐치할 수 없다면 5.0 과 동일한 락을 사용함
    - 이 경우 INSERT 문장 완료시 까지 락이 해제 되지 않음

  - 대량 INSERT 의 경우 한 번에 할당 받아 사용함

  - 단, 실패 할 경우 해당 값 만큼 누락되는 문제가 발생
 
- innodb_autoinc_lock_mode=2
  - 절대 자동 증가 락을 걸지 않고 경량화된 래치만을 사용

  - 인터리빙모드로 연속된 증가 값을 보장하지 않음

  - 대량 INSERT 문장이 실행되는 중에도 다른 커넥션에서 INSERT를 수행할 수 있어 동시성 처리 성능은 높아짐
    
  - STATEMENT 포맷의 바이너리 로그를 사용하는 복제에서는 소스 서버와 레플리카 버서의 자동 증가 값이 달라질 수 있기에 주의해야 함

- 자동 증가 값이 한번 증가하면 줄어들지 않는 이유는 AUTO_INCREMENT 잠금을 최소화하기 위함
  - 쿼리가 실패하더라도 증가한 값은 줄어들지 않음

> 기본값이 5.7까지는 1이었고, 8.0부터는 2로 바뀌었음
이는 8.0부터 바이너리 로그 포맷이 ROW로 바뀌었기 때문

### 5.3.2 인덱스와 잠금
- InnoDB 의 락은 레코드를 잠그는 것이 아닌 **인덱스를 잠그는 방식**

- **변경할 레코드를 찾기 위해 검색한 인덱스의 레코드에 모두 락** 을 건다

- 이해를 돕기 위해 아래 예시를 살펴보자

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/51b316d4-8057-416c-ac39-ed6f07042473)

- 위 UPDATE 문 실행시 1 건의 레코드가 업데이트 됨

- WHERE 절에서 사용가능한 인덱스는 `first_name` 뿐이고 `last_name` 은 인덱스가 존재하지 않음

- 따라서 `first_name = 'Georgi` 에 해당하는 레코드가 모두 락이 걸린다
  - 1,000건 이라면 1,000건이 모두 락이 걸림

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/89c5ab41-af1f-4cb9-8cf1-268d569fcc6a)

- 위 그림처럼 MySQL 은 `실제 UPDATE 되는 레코드와 락이 잡히는 레코드가 다르다`
  
- 만약 인덱스가 하나도 존재하지 않는다면, **테이블 풀 스캔이 발생해 모든 데이터가 락** 이 걸림
  - 한 세션에서 UPDATE 작업을 하는 중에는 다른 클라이언트는 그 테이블을 업데이트하지 못하고 기다려야 하는 상황이 발생

  - MySQL에서 인덱스 설계가 중요한 이유

### 5.3.3 레코드 수준의 잠금 확인 및 해제
- InnoDB 엔진을 사용하는 테이블의 레코드 레벨 락은 테이블 레벨 락 보다 복잡함
  - 테이블이 통째로 잠금에 걸리면 문제 원인이 쉽게 발견되고 해결할 수 있음
  
- 레코드 레벨의 락은 **테이블의 레코드 각각에 잡혀** 오랫동인 락이 걸려있어도 발견되지 않는 경우도 존재함
 - 자주 사용되지 않는다면 이 문제를 찾기가 힘들 수 있음
   
- 5.1 버전 부터는 레코드 레벨 락과 락 대기에 대한 조회가 가능해짐
  - 각 트랜잭션이 어떤 락을 대기하고 있는지 확인 가능
    
- 8.0 버전 부터는 조금 변경됨
  - `performance_schema.data_locks`
  
  - `performance_schema.data_lock_waits`

- KILL 명령어를 통해 해당 프로세스를 킬하면 강제로 락이 종료됨

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/217e32a9-89a3-47e8-a4f9-13e2792a46a0)

**`프로세스 목록 조회`**

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/84fb1258-c866-4767-9e70-984c18ec8929)

- 17번 스레드는 UPDATE 실행 완료
  - 아직 COMMIT은 안되었음 → 레코드 락 보유

- 18번, 19번 UPDATE 실행 중 → 잠금 대기 중

**`잠금 대기 순서 조회`**

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/37125441-1ff7-471a-a5c2-ded071a24bf7)

- 18,19번 스레드 대기중
  - 17 ← 18 ← 19

**`잠금 내용 상세 조회`**

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/21c88f81-a838-41bb-ada6-67e33ca79c64)

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/8a3fbdbd-9fb6-4440-a37e-b7b3e420e7b5)

- employees 테이블에 대해 IX 락(Intentional Exclusive)과 특정 레코드에 대해 쓰기 잠금을 가짐

- REC_NOT_GAP 표시가 있음으로 레코드 잠금은 갭이 포함되지 않은 순수 레코드 잠금

- 17번 스레드가 오래 멈춰있는 경우 강제 종료하면 나머지 UPDATE 실행되며 경합이 해제됨

```mysql
KILL 17;
```
