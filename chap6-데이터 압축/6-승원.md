# 6장 데이터 압축

MySQL 서버에서 디스크에 저장된 데이터의 크기는 작을수록 쿼리의 성능, 백업 및 복구 시간이 줄어든다.

데이터 파일이 크면 버퍼 풀이 자주 변경되어 성능에 부정적인 영향을 끼친다.

# 페이지 압축(Transparent Page Compression)

디스크에 저장될 때 페이지를 압축하여 저장하고, 디스크에서 서버로 읽어올 때 페이지의 압축을 푸는 방법이다. 즉 버퍼 풀에 데이터가 적재되면 압축이 해제된 상태로 페이지를 관리하게 된다.

압축된 페이지의 크기를 알 수 없기 때문에 펀치 홀이라는 기능을 사용한다. OS나 하드웨어에서 지원하지 않는 경우가 있어 실제 페이지 압축은 많이 사용되지 않는 상태이다.

* 펀치 홀

페이지를 압축하기 전의 공간을 할당한 뒤, 압축하여 저장  후 남은 디스크 공간을 OS로 반납하는 방법.

# 테이블 압축

OS나 하드웨어에 대한 제약이 없기 때문에 일반적으로 더 많이 활용된다. 디스크 데이터 파일을 줄일 수 있지만, 버퍼 풀 공간 활용도와 쿼리 처리 성능이 낮고, 빈번한 데이터 변경 시 압축률이 떨어진다는 단점이 있다.

### 테이블 압축 과정

1. 압축 테이블 생성
    
    압축하려는 테이블은 별도의 테이블 스페이스를 사용해야 한다. 이를 위해 `innodb_file_per_table` 시스템 변수를 ON으로 하고 테이블을 생성해야 한다. 그리고 테이블을 생성할 때 `ROW_FORMAT=COMPRESSED` 옵셜을 명시해야 한다. 이 것 외에도 `KEY_BLOCK_SIZE` 옵션으로 압축된 페이지의 목표 크기를 명시할 수 있다.
    
    압축된 결과가 BLOCK_SIZE 보다 큰 경우 나눠서 저장하게 된다.
    
    ![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/a994cb42-a520-409b-b00b-83586a35efff)

    
2. KEY_BLOCK_SIZE 결정
    
    테이블 압축에서 가장 중요한 것은 **압축된 결과를 예측해서  KEY_BLOCK_SIZE를 결정**하는 것이다. 그래서 테이블 압축 전에 KEY_BLOCK_SIZE를 4KB 또는 8KB를 지정해서 샘플 데이터를 인서트하고 진행해보는 것이 좋다. 이때 압축 실패율을 확인할 수 있는데, 페이지 크기보다 커서 스플릿한 비율을 뜻한다. 실패율은 3~5% 미만으로 유지하는 것이 좋다.
    
    8KB로 했음에도 압축 실패율이 높다면, 압축하는 과정이 오래걸린다고 보면 된다. 따라서 성능이 민감한 서비스라면 그 테이블은 압축하지 않는 것을 권장한다. (테이블의 데이터가 빈번하게 조회/변경 된다면 압축을 고려하지 않는다.)
    
3. 압축된 페이지 버퍼 풀에 적재 및 사용
    
    InnoDB 스토리지 엔진은 압축된 테이블의 데이터 페이지를 버퍼 풀에 적재하면, 읽은 상태 그대로의 데이터 페이지 목록은 LRU 리스트로, 압축 해제한 Unzip_LRU 리스트로 관리된다.
    
    두가지 페이지 리스트를 갖기 때문에 메모리가 낭비되는 단점이 있다. 그럼에도, 압축된 페이지에서 데이터를 읽거나 변경하기 위해 압축을 해제해야 되는데, 압축/해제 작업은 CPU를 상대적으로 많이 소모하기 때문에 Unzip_LRU 리스트를 별도로 관리한다.
    
    버퍼 풀 공간이 부족하거나, 사용되지 않는 데이터 페이지는 LRU 리스트에서 제거한다.
    
    CPU 사용량이 높으면 Unzip_LRU 비율을 높이고, DISK IO가 높으면 낮춘다.
    
4. 테이블 압축 관련 설정
    
    페이지 압축 실패율을 낮추기 위한 몇가지 시스템 변수가 있다.
    
    - innodb_cmp_per_index_enabled
        
        압축된 테이블의 인덱스별로 압축 성공 및 압축 실행 횟수를 수집하도록 설정한다. 
        
        OFF되면 테이블 단위의 압축 성공 및 압축 실행 횟수만 수집된다.
        
        테이블 단위로 수집된 정보는 information_schema.INNODB_CMP 테이블에 기록되며, 인덱스 단위로 수집된 정보는 information_schema.INNODB.CMP_PER.INDEX 테이블에 기록된다.
        
    - *annodb_compression_level*
        
        InnoDB의  압축은 zlib 압축 알고리즘만 지원하는데 압축률을 설정할 수 있다.
        
        0~9 중에서 선택할 수 있는데, 값이 작을수록 압축 속도는 빨라지지만 저장 공간은 커질 수 있다. 반대로 값이 커질수록 속도는 느려질 수 있지만 압축률은 높아진다. 기본값은 6으로, 압축 속도와 압축율 모두 중간 정도로 선택한 값이다. 여기서 압축 속도는 CPU 자원 소모량과 동일한 의미다. 즉, 압축 속도가 빨라진다는 것은 CPU 자원을 그만큼 적게 사용한다는 뜻
        
    - innodb_compression_failure_threshold_pct, innodb_compression_pad_pct_max
        
        테이블 압축 실패율이 innodb_compression_failure_threshold_pct 시스템 설정값보다 커지면 압축을 실행하기 전 원본 데이터 페이지의 끝에 의도적으로 일정 크기의 빈 공간을 추가한다.
        
        추가된 빈 공간은 압축률을 높여서 압축 결과가 KEY_BLOCK_SIZE 보다 작아지게 만든다. 여기서 추가하는 빈 공간을 Padding이라고 하며, 이 공간은 압축 실패율이 높아질수록 계속 증가된 크기를 가지는데, 추가할 수 있는 최대 크기는 innodb_compression_pad_pct_max 변수에 저장된 %값이다.
        
    - innodb_log_compressed_pages
        
        MySQL 서버가 비정상적으로 종료됐다가 다시 시작되는 경우 압축 알고리즘의 버전 차이가 있더라도 복구 과정이 실패하지 않도록 압축된 데이터 페이지를 그대로 리두 로그에 기록한다.
        
        이는 압축 알고리즘을 업그레이드할 때 도움이 되지만, 데이터 페이지를 통째로 리두 로그에 저장하는 것은 리두 로그의 증가량에 상당한 영향을 미칠 수도 있다. 압축을 적용한 후 리두 로그 용량이 매우 빠르게 증가한다거나 버퍼 풀로부터 더티 페이지가 한꺼번에 많이 기록되는 패턴으로 바뀌었다면 innodb_log_compressed_pages 시스템 변수를 OFF로 설정한 후 모니터링 해보는 것이 좋다. 변수의 기본값은 ON인데, 가능하면 기본값인 ON 상태를 유지하자.
