# 7장 데이터 암호화

5.7 버전에 등장한 데이터 암호화는 테이블 스페이스만 암호화를 했었다. 8.0 버전부터 리두/언두 로그, 바이너르 로그 등 모두 암호화를 지원하고 있다.

데이터 암호화는 필수적이며 핀테크의 경우 응용프로그램 + 데이터베이스로 이중 암호화 방법을 선택하기도 한다. 

응용프로그램 → 컬럼 암호화 

데이터베이스 → 테이블 암호화

# MySQL 서버의 데이터 암호화

데이터베이스 서버에서 디스크로 데이터를 읽기/쓰기 할때 암호화 또는 복호화를 진행한다. 즉 InnoDB I/O에서 한다는 뜻.(TDE)

MySQL 서버에서 쿼리를 처리할때 테이블 데이터의 암호화 유무를 몰라도 된다.

### 2단계 키관리

TDE에서 암호화 키는 KeyRing 플러그인에 의해 관리되며, MySQL 8.0에선 총 네가지 키링을 지원한다.

- keyring_file File-Based (엔터프라이즈에서 사용 가능)
- keyring_encrypted_file Keyring 플러그인
- keyring_okv KMIP플러그인
- keyring_aws AWS Keyring 플러그인

위 플러그인은 키를 관리하는 방법만 다를 뿐 내부동작은 모두 동일하다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/7d4641cf-52c6-4eab-a165-5f5d0bddf125)

MySQL 키링 플러그인은 2단계 키 관리 방식을 사용한다. 마스터 키와 테이블스페이스 키를 사용하는데, 테이블 스페이스 키는 private key라고 불린다. 마스터 키는 HashCorp같이 외부 키 관리 솔루션 또는 디스크 파일 플러그인에서 가져오고,  마스터 키를 이용해 테이블스페이스 키를 암호화해서 각 테이블의 데이터 파일 헤더에 저장한다.

마스터 키는 외부로 노출될 수 있기 때문에 주기적으로 변경해야하고, 테이블스페이스 키는 외부로 노출될 일이 없기 때문에 괜찮다. 마스터 키를 변경하면 각 테이블의 테이블스페이스 키를 모두 복호화 하고 새로운 마스터 키로 다시 암호화 한다. 키를 변경하게 되면 엄청난 작업을 처리해야 하며, 데이터파일을 수정할 수 없기 때문에 사용자에게도 상당한 영향을 끼친다.

### 암호화와 성능

한 번 읽은 페이지 (메모리 적재) → 암호화되지 않은 테이블과 성능 같음

안읽은 페이지 → 복호화 시간 걸림(쿼리 지연)

암호화된 페이지 변경사항 동기화시 → 암호화 시간 걸림

암호화 과정은 백그라운드로 진행되기 때문에 쿼리 지연이 일어나지 않는다.

AES 암호화 알고리즘은 암호화될 테이블의 크기에 따라 암호화 전후가 동일한 크기를 갖는다. 그래서 InnoDB 버퍼풀과 메모리의 효율이 달라지진 않는다.

암호화 + 압축을 실행할 경우 압축을 먼저 실행한다. (압축 효율을 높이고, 암호화 빈도를 줄이기 위함)

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/713405d3-9fb1-4183-ad19-effdc5fb1f37)

읽기 쓰기 모두 5배 가량 지연이 생기는걸 알 수 있다.

### 암호화와 복제

마스터-슬레이브 관계인 데이터베이스에 사용되는 마스터키가 다르기 때문에 데이터 파일이 동일하지 않다. 

레플리카 서버로 복제할 때 두 서버 모두 새로운 마스터키를 발급 받는다. 그리고 MySQL 서버를 백업할 때 TDE의 키링 파일을 백업하지 않는 경우가 있는데, 이를 분실하면 복구가 불가능하다.

키링 파일을 별도로 백업한다면 마스터 키의 변경 이력을 기록해야 한다.

# keyring_file 플러그인 설치

keyring_file 플러그인은 마스터 키를 평문의 디스크 파일로 관리한다. 따라서 파일이 노출되면 보안이 뚫린다.

MySQL 서버의 다른 플러그인과 다르게 TDE 플러그인은 가장 빨리 초기화돼야 한다. 따라서 my.cnf 파일에 이와같이 설정하면 된다.

```java
early-plugin-load = keyring_file.so
keyring_file_data = /마스터키/저장/경로/tde_master.key
```

저장 경로는 오직 하나의 MySQL 서버만 사용해야 하기 때문에 여러대를 사용하려면 마스터키를 여러개 만들어주자

MySQL 서버가 실행되면 저장경로에 빈 파일이 생성되고, 마스터 키를 처음 사용할 때 만들어진다.

# 테이블 암호화

어떤 키링 플러그인을 사용하든 관계없이 암호화된 테이블을 생성하고 사용하는 방법은 모두 동일하다.

### 테이블 생성

```java
CREATE TABLE table_name (
	...
) ENCRYPTION='Y';
```

`default_table_encryption` 시스템 변수를 ON으로 설정하면 생성되는 모든 테이블이 암호화된다.

### 응용 프로그램 암호화와 비교

응용 프로그램에서 암호화 하여 MySQL에 저장하는 경우는 서버에서 암호화 여부를 알 수 없다. 따라서 인덱스를 생성하더라도 기능을 100% 활용할 수 없다.

이와 같은 이유로 응용프로그램 vs MySQL 서버 암호화는 서버 암호화를 추천한다.

### 테이블스페이스 이동

테이블을 다른 서버로 복사 또는 특정 테이블의 데이터만 백업하는 경우는 테이블 스페이스 이동(Export & Import)가 레코드 덤프보다 훨씬 빠르다.

TDE 암호화가 적용된 테이블의 경우 목적지와의 마스터 키가 다르기 때문에 `FLUSH TABLES table FOR EXPORT` 를 사용하면 된다.

위 명령이 실행되면 테이블은 잠금이 되고, 테이블의 구조를 테이블명.cfg 파일로 기록한다. 이후 cfg 파일을 목적지 서버에 복사한다. 이때 사용되는 마스터 키는 임시로 발급한 마스터키로 테이블명.cfp로 기록된다.

기존 서버에서 복호화 후 임시 마스터 키로 암호화 하여 목적지 서버로 보내준다.

# 언두 로그 및 리두 로그 암호화

디스크 I/O 만 복호화 했기 때문에 리두/언두 로그는 암호화 되지 않았었다. 하지만 MySQL 8.0.16 버전부터 `innodb_undo_log_encrypt` 와 `innodb_redo_log_encrypt` 를 사용해 암호화할 수 있다.

테이블을 암호화 하면 그때부터 로그도 암호화 하게 되고, 비활성화 하면 그때부터 평문으로 저장하게 된다. 따라서, 비활성화 해도 암호화 키가 필요할 수 있다.

로그 또한 테이블 데이터처럼 테이블스페이스 키로 암호화되고, 테이블스페이스 키는 마스터 키로 암호화 된다. 여기서 사용되는 테이블스페이스 키는 실제 테이블에서 사용된 키가 아니라 각각 로그를 위한 프라이빗 키를 의미한다.

# 바이너리 로그 암호화

테이블을 암후화 해도 바이너리 로그나 릴레이 로그 파일은 평문으로 저장된다. 리두/언두 로그와 다르게 긴 시간 저장되기 때문에 암호화는 더 중요할 수 있다.

바이너리/릴레이 로그는 디스크에 저장된 파일에 대해서만 암호화 되고, 메모리 또는 레플리카 서버와의 통신에서는 암호화하지 않는다. 네트워크에서는 SSL을 사용하자.

### 바이너리 로그 암호화 키 관리

바이너리/릴레이 로그 파일 암호화도 동일한 방식으로 관리된다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/ca30bc4a-0649-49f6-9b3b-0b3fdd7b4afe)

### 바이너리 로그 암호화 키 변경

바이너리 로그 암호화 키가 변경되면 다음의 과정을 거친다.

1. 증가된 시퀀스 번호와 함께 새로운 바이너리 로그 암호화 키 발급 후 키링 파일에 저장
2. 바이너리 로그 파일과 릴레이 로그 파일 스위치(새로운 로그 파일로 로테이션)
3. 새로 생성되는 바이너리 로그와 릴레이 로그 파일의 암호화를 위해 파일 키를 생성하고, 파일 키는 바이너리 로그 파일 키(마스터 키)로 암호화해서 각 로그 파일에 저장
4. 기존 바이너리 로그와 릴레이 로그 파일의 파일 키를 읽어서 새로운 바이너리 로그 파일 키로 암호화해서 다시 저장 (암호화되지 않은 로그 파일은 무시)
5. 모든 바이너리 로그와 릴레이 로그 파일이 새로운 바이너리 로그 암호화 키로 다시 암호화 됐다면 기존 바이너리 로그 암호화 키를 키링 파일에서 제거

4번 과정이 오래 걸릴 수 있기 때문에, 내부적으로 버전이 관리된다.

### mysqlbinlog 도구 활용

암호화된 바이너리 로그를 복호화할 일이 자주 있는데, mysqlbinlog를 이용해 로그를 SQL로 보려해도, 암호화되어있어 볼 수 없다. 로그 파일을 생성한 서버에서만 암호화 키를 가지고 있기 때문이다.

로그 파일을 볼 수 있는 방법은 mysqlbinlog가 서버에 접속해 가져오는 방법이 유일하다.
