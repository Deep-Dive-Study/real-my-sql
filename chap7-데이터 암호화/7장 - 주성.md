# 07. 데이터 암호화
- MySQL 8.0 부터 데이터 파일뿐만 아니라 리두 로그나 언두 로그, 복제를 위한 바이너리 로그 등도 모두 암호화 기능을 지원함

- 응용프로그램의 암호화는 주로 중요 정보를 가진 컬럼 단위로 암호화를 수행하며, 데이터베이스 수준에서는 테이블 단위로 암호화를 적용함

## 7.1 MySQL 서버의 데이터 암호화
- MySQL 서버의 암호화 기능은 데이터베이스 서버와 디스크 사이의 **데이터 읽고 쓰기 지점** 에서 암호화 또는 복호화 수행
  - 그 외의 부분에서는 암호화 처리가 전혀 필요치 않음

  - 즉, MySQL 서버(InnoDB 스토리지 엔진)의 **`I/O 레이어`** 에서만 데이터의 암호화 및 복호화 과정이 실행됨

  ![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/42070b92-5dcc-4aae-ba3f-db1c8cafcf39)

- 데이터 암호화 기능이 활성화돼 있다고 하더라도 MySQL 내부와 사용자 입장에서는 아무런 차이가 없는 암호화 방식
  - 이러한 방식을 **`TDE(Transparent Data Encryption)`** 라고 함

  - `"Data at Rest Encryption"` 라고도 하는데, 여기서 "Data at Rest"는 메모리(In-Process)나 네트워크 전송(InTransit) 단계가 아닌 디스크에 저장(At Rest)된 단계에서만 암호화된다는 의미로 사용되는 표현

### 7.1.1 2단계 키 관리
- MySQL 서버의 TDE 에서 암호화는 **키링 플러그인** 에 의해 관리됨

- MySQL 8.0 버전에서 지원되는 키링 플러그인
  - **`keyring_file` File-Based 플러그인 (커뮤니티 에디션도 사용 가능)**
    
  - `keyring_encrypted_file` Keyring 플러그인
    
  - `keyring_okv` KMIP 플러그인
    
  - `keyring_aws` Amazon Web Services Keyring 플러그인

  →  다양한 플러그인이 제공되지만 마스터 키를 관리하는 방법만 다를 뿐 MySQL 서버 내부적으로 작동하는 방식은 모두 동일

- 키링 플러그인은 **`2단계 키 관리 방식`** 을 사용

  ![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/b8bc9bb3-b75b-4d31-8a63-9f8d382ed045)

- **`마스터 키`** 와 **`테이블스페이스 키(프라이빗 키)`** 라는 두 가지 종류의 키로 구성
  - HashiCorp Vault 같은 외부 키 관리 솔루션 또는 디스크의 파일에서 마스터 키를 가져옴
  
  - 암호화된 테이블이 생성될 때마다 해당 테이블을 위한 임의의 테이블스페이스 키를 발급
    
- MySQL 서버는 마스터 키를 이용해 테이블스페이스키를 암호화해서 **각 테이블의 데이터 파일 헤더에 저장**

- 생성된 테이블스페이스 키는 테이블이 삭제되지 않는 이상 절대 변경되지 않음(외부로 노출되지 않기에 주기적으로 변경하지 않아도 보안상 취약점이 되지 않음)

- 하지만, 마스터 키는 외부 파일을 이용하기 때문에 노출 가능성이 있으므로 **주기적으로 변경이 필요함**
  
  ```mysql
  ALTER INSTANCE ROTATE INNODB MASTER KEY;
  ```
  
- **마스터 키를 변경하면 MySQL 서버는 기존의 마스터 키를 이용해 각 테이블의 테이블스페이스 키를 복호화한 다음 새로운 마스터 키로 다시 암호화함**
  - 마스터 키가 변경되는 동안 MySQL 서버의 테이블스페이스 키 자체와 데이터 파일의 데이터는 전혀 변경되지 않음

  - MySQL 서버에서 이렇게 2단계 암호화 방식을 사용하는 이유는 암호화 키 변경으로 인한 **과도한 시스템 부하를 피하기 위해서** 임

  - 만약, 테이블스페이스 키가 변경된다면 데이터 파일의 모든 데이터를 다시 복호화했다가 다시 암호화해야 하는 부하를 갖게 됨

- TDE 에서 지원되는 암호화 알고리즘은 **AES 256 비트** 이며, 이외의 알고리즘은 지원되지 않음

  - 테이블 스페이스 키는 AES-256 ECB(Electronic CodeBook) 알고리즘을 이용
  
  - 실제 데이터 파일은 AES-256 CBC(Cipher Block Chaining) 알고리즘을 이용

### 7.1.2 암호화와 성능
- MySQL 서버의 암호화는 TDE 방식이기 때문에 디스크로부터 한 번 읽은 데이터 페이지는 복호화되어 InnoDB 의 버퍼 풀에 적재됨

- 데이터 페이지가 한 번 메모리에 적재되면 암호화되지 않은 **테이블과 동일한 성능을 보임**
    
  - 쿼리가 InnoDB 버퍼 풀에 존재하지 않는 **데이터 페이지를 읽어야 하는 경우에는 복호화 과정을 거치기 때문에 복호화 시간 동안 쿼리 처리가 지연됨** 
  
  - 암호화된 테이블이 변경되면 다시 디스크로 동기화될 때 암호화돼야 하기 때문에 **디스크에 저장할 때도 추가로 시간이 더 걸림**
  
  - 다만, 데이터 페이지 저장은 사용자의 쿼리를 처리하는 쓰레드가 아닌 MySQL 서버 백그라운드 쓰레드가 수행하기 때문에 실제 사용자 쿼리가 지연되는 것은 아님

- 암호화한다고 해서 **InnoDB 버퍼 풀의 효율이 달라지거나 메모리 사용 효율이 떨어지는 현상은 발생하지 않음**
  - AES 암호화 알고리즘은 암호화 결과가 평문의 결과와 동일한 크기의 암호문을 반환
    - 암호화하고자 하는 평문의 길이가 짧은 경우 암호화 키의 크기에 따라 암호화된 결과의 용량이 더 커질 수도 있지만, 이미 데이터 페이지는 암호화 키보다 훨씬 큼
    
  → 즉, 데이터 파일의 크기는 암호화되지 않은 테이블과 동일한 크기를 가진다.
    
- 같은 테이블에 대해 암호화와 압축이 동시에 적용되면 MySQL 서버는 **압축을 먼저 실행하고 암호화를 적용함**
  - 암호화된 결과문은 아주 랜덤한 바이트 배열을 가지게 되는데, 이는 압축률을 상당히 떨어뜨림
    - 최대한 압축 효율을 높이기 위해 사용자의 데이터를 그대로 압축해서 용량을 최소화한 후 암호화를 적용

  - 암호화된 테이블의 데이터 페이지는 복호화된 상태로 InnoDB 버퍼 풀에 저장되지만, 압축된 데이터 페이지는 압축 또는 압축 해제의 모든 상태로 InnoDB 버퍼 풀에 존재할 수 있음
    - 그래서 암호화가 먼저 실행되고 압축이 적용된다면 MySQL 서버는 InnoDB 버퍼 풀에 존재하는 데이터 페이지에 대해서도 매번 암복호화 작업을 수행해야함

- 암호화된 테이블과 그렇지 않은 테이블의 디스크 읽고 쓰기에 걸리는 평균 시간
  - 암호화된 테이블의 경우 읽기는 3 ~ 5배 정도, 쓰기는 5 ~ 6배 느림

  ![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/edd9c058-9e68-4310-b7b9-256c5de2718b)

  - 암호화된 테이블의 읽고 쓰기 성능 확인 쿼리
  ```mysql
  SELECT (sum(sum_timer_read)/sum(count_read)) / 1000000000 AS avg_read_latency_ms
         ,(sum(sum_timer_write)/sum(count_write)) / 1000000000 AS avg_write_latency_ms
  FROM performance_schema.file_summary_by_instance
  WHERE file_name LIKE '%DB_NAME/TABLE_NAME%';
  ```

### 7.1.3 암호화와 복제
- MySQL 서버의 복제에서 TDE를 이용한 암호화 사용 시 마스터 키와 테이블스페이스 키는 레플리카 서버에서 동일하지 않음 
  - 마스터 키 자체가 복제되지 않기 때문에 테이블스페이스 키 또한 레플리카로 복제되지 않음

  - 따라서, 실제 암호화된 데이터가 저장된 데이터 파일의 내용은 완전히 달라짐

- 복제 소스 서버의 마스터 키를 변경할 때 (이전 마스터 키 변경 명령과 동일)
    
    ```mysql
    ALTER INSTANCE ROTATE INNODB MASTER KEY;
    ```
    
  - 명령 자체는 레플리카 서버로 복제되지만 실제 소스 서버의 마스터 키 자체가 레플리카로 전달되는 것은 아님

  - 따라서, 마스터 키 로테이션을 실행하면 소스 서버와 레플리카 서버가 각각 서로 다른 마스터 키를 새로 발급받게 됨

- MySQL 서버의 백업에서 TDE의 키링 파일을 백업하지 않는 경우가 있는데, 이 경우 키링 파일을 찾지 못하면 데이터 복구를 할 수 없음
  - 백업마다 키링 파일의 백업도 함께 고려하는 것이 중요

  - 키링 파일을 데이터 백업과 별도로 백업한다면 마스터 키 로테이션 명령으로 TDE 의 마스터 키가 언제 변경됐는지까지 기억해야 함
    - 보안을 위해 키링 파일을 데이터 파일과 별도로 보관하는 것을 권장

    - 복구를 감안하고 백업 방식을 선택해야 함

## 7.2 keyring_file 플러그인 설치
- TDE 의 암호화 키 관리는 플러그인 방식으로 제공됨
    
- `keyring_file` 플러그인은 테이블스페이스 키를 암호화하기 위한 마스터 키를 디스크의 파일로 관리하는데, 이때 마스터 키는 평문으로 디스크에 저장됨
  - `마스터 키가 저장된 파일이 외부에 노출된다면 데이터 암호화는 무용지물이 되어버림`

- MySQL 서버가 시작될 때만 키링 파일을 다른 서버로부터 다운로드해서 로컬 디스크에 저장한 후 서버를 시작하는 방법을 고려해보자
  - 일단 MySQL 서버가 시작되면 서버가 마스터 키를 **메모리에 캐시하기 때문에** 로컬 디스크의 키링 파일을 삭제해도 서버가 작동하는 데는 아무런 문제가 없음

  - **마스터 키를 로테이션하는 경우에는 로컬의 키링 파일이 최신이 되므로 다시 외부 서버에 복사해 둬야 함**

  - Percona Server 는 HashiCorp Vault 를 연동하는 키 관리 플러그인을 오픈소스로 제공
    - 커뮤니티 에디션에서도 문제없이 사용할 수 있으므로 Percona Server 의 `keyring_vault` 플러그인도 함께 검토해볼 것을 권장

- TDE 플러그인의 경우 MySQL 서버가 시작되는 단계에서도 **가장 빨리 초기화돼야 함**
  - 서버의 설정 파일(`my.cnf`)에서 `early-plugin-load`에 `keyring_file`플러그인을 위한 라이브러리("`kering_file.so`")를 명시하면 됨

  - 그리고 `keyring_file`플러그인이 마스터 키를 저장할 키링 파일의 경로를 `kering_file_data` 설정에 명시하면 됨

  - 경로는 오직 하나의 MySQL 서버만 참조해야 함
    
  ```bash
  # /etc/my.cnf
  early-plugin-load = keyring_file.so
  keyring_file_data = /very/secure/directory/tde_master.key
  ```
    
- `keyring_file` 플러그인의 초기화 여부는 `SHOW PLUGINS` 명령으로 확인 가능
      
    ```bash
    mysql> SHOW PLUGINS;
    ```

    ![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/41b4b2f8-d096-4efd-a06f-0a35187a86bd)


- `keyring_file` 플러그인이 초기화되면 MySQL 서버는 플러그인의 초기화와 동시에 `keyring_file_data`시스템 변수의 경로에 빈 파일을 생성함

- 데이터 암호화 기능을 사용하는 테이블을 생성하거나 마스터 로테이션을 실행하면 키링 파일의 마스터 키가 초기화됨
    
    ```bash
    > ls -alh tde_master.key
    ```    

## 7.3 테이블 암호화
- 키링 플러그인은 마스터 키를 생성하고 관리하는 부분까지만 담당하기 때문에 **어떤 키링 플러그인을 사용하든 관계없이 암호화된 테이블을 생성하고 활용하는 방법은 모두 동일**

### 7.3.1 테이블 생성
- **`TDE 를 이용하는 테이블 생성`**
  - 일반적인 테이블 생성 구문과 동일하며, 마지막에 **`ENCRYPTION='Y'`** 옵션만 추가로 넣으면 됨
    
    ```mysql
    CREATE TABLE tab_encrypted (
             id INT,
             data varchar(100),
             PRIMARY KEY(id)
           ) ENCRYPTION = 'Y';
    ```
    
    - 이제부터 이 테이블의 데이터가 디스크에 기록될 때는 데이터가 자동으로 암호화되어 저장되고, 다시 디스크에서 메모리로 읽어올 때 복호화됨

- 암호화된 테이블만 검색할 때는 `information_schema`의 `TABLES`뷰를 이용하면 됨
    
    ```mysql
    SELECT table_schema, table_name, create_options
             FROM information_schema.tables
            WHERE table_name = 'tab_encrypted';
    ```

- MySQL 서버의 모든 테이블에 대해 암호화를 적용하고자 한다면 `default_table_encryption` 시스템 변수를 ON 으로 설정하면 `ENCRYPTION`옵션을 별도로 설정하지 않아도 암호화된 테이블로 생성됨
    
    ```mysql
    SHOW VARIABLES LIKE '%default_table_encryption%';
    ```

### 7.3.2 응용 프로그램 암호화와의 비교
- 응용 프로그램에서 직접 암호화해서 MySQL 서버에 저장하는 경우도 있는데, 이 경우 저장되는 컬럼의 값이 이미 암호화된 것인지 여부를 서버는 이를 인지하지 못함
  → 인덱스를 생성하더라도 인덱스의 기능을 100% 활용할 수 없음

  → 응용 프로그램의 암호화와 MySQL 서버의 암호화 기능 중 선택해야 하는 상황이라면 고민할 필요 없이 **MySQL의 암호화 기능을 선택할 것을 권장**
    
- **응용 프로그램의 암호화와 MySQL 서버의 암호화는 목적과 용도가 다름**
  - MySQL 서버의 TDE 기능으로 암호화한다면 MySQL 서버에 로그인만 할 수 있다면 모든 데이터를 평문으로 확인할 수 있음
    
  - 하지만 응용프로그램 암호화는 MySQL 서버에 로그인할 수 있다고 하더라도 평문의 내용을 확인할 수 없음

- 응용 프로그램에서의 암호화 기능은 서비스의 요건과 성능을 고려해서 선택해야 하고, MySQL 암호화 기능과 혼합해서 사용한다면 더 안전한 서비스를 구축할 수 있음

### 7.3.3 테이블스페이스 이동
- 테이블을 다른 서버로 복사해야 하는 경우 또는 특정 테이블의 데이터 파일만 백업했다가 복구하는 경우라면 테이블스페이스 이동(Export & Import) 기능이 레코드를 덤프했다가 복구하는 방식보다 훨씬 효율적이고 빠름

- 그런데, TDE 가 적용되어 암호화된 테이블의 경우 원본 MySQL 서버와 목적지 MySQL 서버의 **암호화 키(마스터 키)가 다르기 때문에 하나 더 신경써야 할 부분이 생김**

**`암호화되지 않은 테이블의 테이블스페이스 복사 과정`**

- `FLUSH TABLES` 명령으로 테이블스페이스를 익스포트할 수 있음
      
```mysql
FLUSH TABLES source_table FOR EXPORT;
```
      
- 이 명령이 실행되면 MySQL 서버는 source_table 의 저장되지 않은 변경 사항을 모두 디스크로 기록하고, 더이상 source_table 에 접근할 수 없게 잠금을 검
      
```mysql
FLUSH TABLES tab_encrypted FOR EXPORT;
INSERT INTO tab_encrypted VALUES (2, 'test_data2');
-- ERROR 1099 (HY000): Table 'tab_encrypted' was locked with a READ lock and can't be updated
```
      
- 그와 동시에 source_table 의 구조를 `source_table.cfg` 파일에 기록

- 그러면 `source_table.ibd` 파일과 `source_table.cfg` 파일을 목적지 서버로 복사

- 복사가 모두 완료되면 `UNLOCK TABLES` 명령을 실행해 source_table 을 사용할 수 있게 하면 됨
      
```mysql
UNLOCK TABLES;
INSERT INTO tab_encrypted VALUES (2, 'test_data2');
-- Query OK, 1 row affected (0.00 sec)
```
        
**`암호화된 테이블 복사과정`**

- `FLUSH TABLES source_table FOR EXPORT` 명령 실행 시 MySQL 서버는 임시로 사용할 마스터 키를 발급해서 `source_table.cfp`라는 파일로 기록
  - `*.cfg` 파일은 단순히 테이블의 구조만 가지고 있기 때문에 파일이 없어져도 경고만 발생하고 테이블스페이스를 복구할 수 있지만 `*.cfp` 파일이 없어지면 복구가 불가능함 

- 그리고, 암호화된 테이블의 테이블스페이스 키를 기존 마스터 키로 복호화한 후, 임시로 발급한 마스터 키를 이용해 다시 암호화해서 데이터 파일의 헤더 부분에 저장

- 테이블스페이스 이동 기능을 사용할 때는 반드시 데이터 파일과 **임시 마스터 키가 저장된 `*.cfp` 파일을 함께 복사해야 함**

## 7.4 언두 로그 및 리두 로그 암호화
- MySQL 서버의 메모리에 존재하는 데이터는 복호화된 평문으로 관리되며, 이 평문 데이터가 테이블의 데이터 파일 이외의 디스크 파일로 기록되는 경우에는 여전히 평문으로 저장됨

- MySQL 8.0.16 버전부터는 `innodb_undo_log_encrypt`, `innodb_redo_log_encrypt` 시스템 변수를 이용해 InnoDB 스토리지 엔진의 리두 로그와 언두 로그를 암호화된 상태로 저장할 수 있게 개선됨
    
- 활성화 시점에 저장된 리두 로그와 언두 로그는 **`그 시점의 암호화 키가 필요`**
  - 따로 키 보관이 필요함

- 리두 로그와 언두 로그 데이터 모두 각각의 테이블스페이스 키로 암호화되고, 테이블스페이스 키는 다시 마스터 키로 암호화됨(이중 구조 동일)
  - 테이블스페이스 키는 실제 테이블의 암호화에 사용된 테이블스페이스 키가 아니라 리두 로그와 언두 로그 파일을 위한 프라이빗 키를 의미

  - 리두 로그와 언두 로그를 위한 각각의 프라이빗 키가 발급되고, 해당 프라이빗 키는 마스터 키로 암호화되어 리두 로그 파일과 언두 로그 파일의 헤더에 저장

**`InnoDB 리두 로그 암호화 확인`**
    
  ```bash
  mysql> SHOW VARIABLES LIKE '%innodb_redo_log_encrypt%';
  -- // 암호화 설정
  mysql> SET GLOBAL innodb_redo_log_encrypt=ON; 
  ```
    
  - `INSERT`된 레코드의 문자열이 InnoDB 의 리두 로그에 보이는지만 확인해보면 됨
    - `grep` 명령을 이용한 단순한 검색 결과에서 암호화되기 전에 `INSERT`한 문자열은 검색되지만 암호화 이후 `INSERT`된 문자열은 검색되지 않음

  ![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/c1126df1-44b1-4839-ac32-c254e4175122)

## 7.5 바이너리 로그 암호화
- 테이블 암호화가 적용돼도 바이너리 로그와 릴레이 로그 파일 또한 리두 로그나 언두 로그처럼 평문을 저장함
  - 바이너리 로그는 의도적으로 긴 시간 보관하는 서비스도 있고, 증분 백업(Incremental Backup)을 위해 보관하기도 하므로, 바이너리 로그의 암호화는 상황에 따라 중요도가 높아질 수 있음

  - 바이너리 로그와 릴레이 로그 파일 암호화 기능은 디스크에 저장된 로그 파일에 대한 암호화만 담당하고, MySQL 서버의 메모리 내부 또는 소스 서버와 레플리카 서버 간의 네트워크 구간에서 로그 데이터를 암호화하지 않음

    → 복제 멤버 간의 네트워크 구간에서도 바이너리 로그를 암호화하고자 한다면 MySQL 복제를 위한 계정(slave)이 SSL 을 사용하도록 설정하면 됨

### 7.5.1 바이너리 로그 암호화 키 관리

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/1397f9e9-f2a1-4ec8-bf83-d4f0ec660b56)

- 바이너리 로그와 릴레이 로그 파일의 데이터는 파일 키로 암호화해서 디스크로 저장하고, 파일 키는 **“바이너리 로그 암호화 키”** (마스터 키와 동일한 역할)로 암호화해서 각 바이너리 로그와 릴레이 로그 파일의 헤더에 저장
  - 이중 구조는 동일, 해당 로그 파일의 암호화를 위한 키가 따로 생성 

### 7.5.2 바이너리 로그 암호화 키 변경
- 바이너리 로그 암호화 키는 다음과 같이 변경(로테이션)할 수 있음

```mysql
ALTER INSTANCE ROTATE BINLOG MASTER KEY;
```
    
**`바이너리 로그 암호화 키가 변경 과정`**

1. 증가된 시퀀스 번호와 함께 새로운 바이너리 로그 암호화 키 발급 후 키링 파일에 저장
   
2. 바이너리 로그 파일과 릴레이 로그 파일 스위치 (새로운 로그 파일로 로테이션)
   
3. 새로 생성되는 바이너리 로그와 릴레이 로그 파일의 암호화를 위해 파일 키를 생성하고, 파일 키는 바이너리 로그 파일 키(마스터 키)로 암호화해서 각 로그 파일에 저장

4. 기존 바이너리 로그와 릴레이 로그 파일의 파일 키를 읽어서 새로운 바이너리 로그 파일 키로 암호화해서 다시 저장(암호화되지 않은 로그 파일은 무시)

5. 모든 바이너리 로그와 릴레이 로그 파일이 새로운 바이너리 로그 암호화 키로 다시 암호화됐다면 기존 바이너리 로그 암호화 키를 키링 파일에서 제거

**`바이너리 로그 파일 암호화 확인`**
    
  ```mysql
  SHOW BINARY LOGS;
  ```
  
### 7.5.3. mysqlbinlog 도구 활용
- 트랜잭션의 내용을 추적하거나 백업 복구를 위해 암호화된 바이너리 로그를 평문으로 복호화가 필요할 경우, 바이너리 로그 암호화 키가 없으면 복호화할 수 없음
  - 로그 암호화 키는 MySQL 서버만 가지고 있어서 복호화할 수 없음

- `mysqlbinlog` 도구를 이용해 확인하면, 로그 파일을 직접 열어 볼 수는 없다는 에러 메시지가 출력됨

  ![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/33ac1288-b493-42c4-ad6f-fac9b8cfaab7)
   
- 따라서, `mysqlbinlog` 도구가 MySQL 서버에 요청해서 바이너리 로그를 가져오는 방법밖에 없음
  - `mysqlbinlog` 명령을 실행할 때 `--read-fromremote-server` 파라미터와 함께 MySQL 서버 접속 정보를 입력해야함

  ![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/08f4930f-9ba4-4eda-951b-2fd2c5fa5518)
