# 8장 인덱스 ( ~ 8.3.5)

# 디스크 읽기 방식

컴퓨터에서 데이터 저장 매체는 컴퓨터에서 가장 느린 부분이다. 따라서 DB 성능 튜닝은 디스크 I/O를 줄이는게 관건일 때가 많다.

### HDD, SDD

기존에 병목이 되던 HDD에서 연산속도가 약 1000배 빠른 SSD로 변경되었지만, 여전히 Random I/O에선 7배, Sequencial I/O 에선 큰 이점이 없어 병목인 것은 변함이 없다.

### Random / Sequencial I/O

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/7eb43d39-a9f0-4397-89e0-18cf71a6d640)

Sequencial I/O는 3개의 페이지를 디스크에 기록하기 위해 시스템 콜을 1번 요청했지만, Random I/O는 시스템 콜을 3번 요청했다. 이런 경우 시간 차이는 거의 3배 난다고 볼 수 있다. DB의 대부분의 작업은 Random I/O여서 MySQL 서버에서는 그룹 커밋이나 바이너리 로그 버퍼, InnoDB 로그 버퍼등의 기능이 있다.

쿼리 튜닝으로 Ramdom I/O 를 Sequencial I/O로 바꾸는 일은 거의 없다. 일반적으로 쿼리 튜닝은 Random I/O를 줄여 개선을 의미한다.

# 인덱스

인덱스는 SortedList와 같다. 따라서 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 이미 정렬되어 있어서 원하는 값을 빨리 찾아올 수 있다. 따라서 인덱스는 데이터의 INSERT, UPDATE, DELETE 성능을 희생하고 SELECT 속도를 높이는 기능이다. 

인덱스는 프라이머리 인덱스와 세컨더리 인덱스로 구분할 수 있는데, 프라이머리 인덱스는 레코드를 대표하는 칼럼으로 만들어진 인덱스를 뜻하며 세컨더리 인덱스는 그외 나머지를 뜻한다.

인덱스는 Hash와 B-Tree로 이루어져 있으며, 대부분 B-Tree이다. 

인덱스의 Unique함에 따라 처리 방식이 크게 달라지는데, 이는 실행 계획 파트에 자세히 서술되어 있다.

### B-Tree

Balanced-Tree를 뜻하며 원래 값을 변형시키지 않고, 항상 정렬된 상태로 관리한다.

**구조 및 특성**

최상위에 루트 노드, 그 하위에 자식 노드가 붙어있는 형태다. 최하위에 있는 노드를 리프 노드라고 하며, 그 사이를 브랜치 노드라고 한다. DB에서 인덱스와 실제 데이터는 따로 관리되는데, 리프 노드는 실제 데이터의 주솟값을 갖고 있다. 따라서, 인덱스 키만 가지고 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 하는데 인덱스 리프노드를 통해 정보를 얻는다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/3c27518f-957f-4fd3-b286-f700d981f294)

데이터 파일은 인덱스 순서와 상관없이 뒤죽박죽이다.

MyISAM은 인덱스에 레코드 주소를 갖는 반면 InnoDB는 클러스터링 구조로 되어있어서 프라이머리 키를 주소처럼 사용한다. 즉 InnoDB에서 세컨더리 인덱스를 사용해서 검색을 할 때 세컨더리 인덱스의 리프 노드에 있는 값을 프라이머리 인덱스에서 다시 검색해야 한다.

### B-Tree 인덱스 키 추가 및 삭제

**추가**

B-Tree에 저장될 때 리프노드에  저장되는데, 리프노트가 꽉찬 경우 브랜치 노드까지 작업 범위가 넓어진다. 따라서 B-Tree 쓰기 작업은 비용이 크다. 보통 레코드 추가 비용이 1이면 인덱스 추가 비용은 1.5정도로 산정하는데, 인덱스가 3개인 경우 레코드 하나 삽입할 때 5.5의 비용이 드는 셈이다. 

다른 스토리지 엔진과 다르게 InnoDB는 지연 처리하기도 하는데, 프라이머리 키나 유니크 인덱스인 경우 중복 체크 때문에 바로 적용한다.

**삭제**

B-Tree의 리프 노드를 찾아서 삭제 마크를 하면 끝이다. 마킹된 공간은 재사용된다. 이 방법도 지연처리 하기도 한다.

**업데이트**

인덱스 업데이트는 기존의 인덱스 값을 삭제 한 후 새로운 키 값을 추가한다.

**검색**

인덱스 트리 탐색은 SELECT 뿐만 아니라 UPDATE, DELETE 작업을 처리하기 위해 사용한다. 보통 인덱스의 100%를 비교하기도 하지만, 인덱스의 일부(앞부분)만 일치하는 경우에도 사용한다.

인덱스 검색을 할 때 인덱스 키 값에 변형이 가해진 경우 더이상 B-Tree에 존재하지 않기 때문에 인덱스를 통한 빠른 검색이 불가능 하다.

### B-Tree 인덱스 사용에 영향을 미치는 요소

**인덱스 키 값의 크기**

데이터를 저장하는 가장 기본 단위인 Page의 크기와 인덱스 키 값의 크기는 중요하다.

B-Tree의 자식 노드의 수는  Page / (인덱스 키 값 + 자식 노드 주소) 이기 때문에 인덱스 키 값이 작을수록 자식 노드가 많고, 깊이가 얕아지게 된다.

**B-Tree의 깊이**

한 페이지의 크기가 크면 디스크 I/O 횟수가 줄어들어 효율이 늘어난다.

즉 B-Tree의 깊이가 깊어질수록 디스크 읽기 연산이 늘어난다.

**카디널리티**

인덱스는 카디널리티가 높을수록 검색 대상이 줄어들기 때문에 그만큼 속도가 빨라진다.

**읽어야 하는 레코드 건수**

100만건의 레코드가 있는 테이블에서 50만건을 읽어야 하는 쿼리가 있으면, 인덱스보다 풀테이블 스캔을 하는 것이 유리하다. 이는 Random I/O와 Sequencial I/O라서 속도 차이가 있는데, 보통은 20~ 25% 이상의 레코드를 읽을 경우 풀테이블 스캔이 더 유리해서 사용하도록 되어있다.

### B-Tree 인덱스를 통한 데이터 읽기

어떤 상황에서 어떻게 인덱스를 스캔하는지 알아보자.

**인덱스 레인지 스캔**

뒤에서 설명할 두 가지 방법보다 빠른 방법으로, 인덱스를 통해 검색해야 할 인덱스 범위가 결정되었을때 사용한다.

루트 노드부터 시작해 리프 노드를 찾아 순서대로 탐색한다. 이때 실제 인덱스만 반환하는 경우(커버링 인덱스)엔, 인덱스 스캔을 하고 끝이지만, 그렇지 않은 경우엔 데이터 파일을 읽는다. 1건마다 Random I/O 가 일어난다. 따라서 20~25%를 넘어가면 풀테이블 스캔이 더 유리하다.

**인덱스 풀 스캔**

인덱스의 처음부터 끝까지 모두 읽는 방식.

대표적으로 쿼리 조건절에 사용된 컬럼이 인덱스의 첫 컬럼이 아닌 경우 사용한다. 리프노드의 첫 번째 페이지부터 링크드리스트로 이어져있어서 쭉 읽게 된다. 이는 레인지 스캔보다 느리지만, 풀 테이블 스캔보다 빠르다.

인덱스는 테이블보다 훨씬 작기 때문에 적은 디스크 I/O로 쿼리를 처리할 수 있다.

**루스 인덱스 스캔**

인덱스 레인지 스캔과 비슷하지만 리프노드의 페이지를 확인하면서, 필요하지 않은 인덱스 키 값을 스킵하고 다음으로 넘어가는 방식이다. 일반적으로 GROUP BY나 MAX, MIN 함수에서 사용된다.

**인덱스 스킵 스캔**

(gender, birthday) 복합 인덱스에서 WHERE절에 gender가 생략되고, birthday로만 검색을 하게 되면 인덱스를 사용하지 못한다. 이때 첫번째 컬럼의 값을 무시하고 birthday 값으로만 인덱스 검색이 가능하게 해주는 기능이다.

MySQL 8.0 부터 도입된 기능으로 실행 계획을 살펴보면 range, skip scan이라고 나온다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/ec9f1106-ad8a-4e08-a50d-68202d6faa8c)

실제 쿼리는 gender가 가지는 모든 도메인(예를 들어 M, F) + birthday에 대한 검색을 실행하는 것과 비슷하게 작동한다. 따라서 선행 컬럼의 카디널리티가 낮아야 하고, 커버링 인덱스인 경우에만 사용이 가능하다.

### 복합 인덱스

복합 인덱스의 경우 인덱스 내부의 컬럼 순서에 의존하여 정렬된다. 따라서 인덱스 내부의 컬럼 순서는 매우 중요하다.
