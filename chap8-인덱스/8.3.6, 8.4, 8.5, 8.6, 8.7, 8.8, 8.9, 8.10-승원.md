# 8장 (8.3.6 ~)

### B-Tree 인덱스의 정렬 및 스캔 방향

인덱스는 오름차순 또는 내림차순으로 정렬되어 있는데, 어떤 방향으로 읽을지는 옵티마이저가 결정한다.

**인덱스의 정렬**

기존 DBMS 에선 인덱스를 ASC, DESC로 구성할 수 있었으나, 컬럼별로 다르게 지정할 수 없었다. MySQL 8.0부터는 컬럼별로 인덱스 정렬 순서를 혼합할 수 있게 되었다.

인덱스 생성시점에 정렬 순서는 정해지지만, 읽는 방향에 따라 다른 정렬 효과를 가질 수 있다. 

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/ac430445-abb5-49e4-9ba9-ddb14e6c00e1)

다음과 같이 오른차순 정렬된 테이블을 읽는 순서에 따라 정순,역순으로 읽기 가능하다.

인덱스 정순 스캔, 인덱스 역순 스캔중 어떤게 더 빠를까?

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/e14e9aac-c51e-4f55-8299-d57ac80c901f)

오름차순으로 정렬된 t1 테이블에서 정순으로 인덱스 풀스캔을 하는 것과, 역순으로 스캔하는 것은 속도 차이가 있다. 이유는 다음과 같다.

1. 페이지 내에서 인덱스 레코드는 단방향으로만 연결되어 있다.
2. 페이지 락은 인덱스 정순 스캔에 적합한 구조이다.

그렇다고 항상 오름차순 정렬이 효율적인 것은 아니다. 내림차순 정렬 쿼리를 자주 실행하는 경우에는 내림차순 쿼리를 사용해도 좋다.

### B-Tree 인덱스의 가용성과 효율성

범위 결정 조건 : 작업의 범위를 줄이는 조건

필터링 조건 : 작업의 범위를 줄이지 못하는 조건

1. 다중 인덱스의 경우 인덱스의 순서대로 검색 조건으로 사용해야 범위 결정 조건이 적용 된다.
2. 왼쪽 값 부터 비교하는 검색 조건을 사용해야 범위 결정 조건이 적용 된다.
    1. WHERE name LIKE ‘%ike’ 과 같은 쿼리는 좌측에 어떤 값이 들어올지 모르기 때문에 적용이 안된다.
3. NOT EQUAL로 비교된 경우 인덱스를 사용하지 못한다. (<>, NOT IN, IS NOT NULL)
4. 스토어드 함수나 다른 연산자로 변형된 후 비교된 경우 인덱스를 사용하지 못한다.(SUBSTRING, DAYOFMONTH)
5. 비결정적 함수가 비교 조건에 사용되는 경우 인덱스를 사용하지 못한다.
6. 데이터 타입이 다른 비교를 사용하는 경우 인덱스를 사용하지 못한다.
7. 문자열 데이터 타입의 콜레이션이 다른 경우

# R-Tree 인덱스

R-Tree는 B-Tree와 흡사하지만, 2차원 공간 개념 값이라는 점이 다르다. MySQL의 공간 인덱스에 사용하고, 공간 확장을 사용하여 구현할 수 있다.

### 구조 및 특성

MySQL은 공간 정보의 저장 및 검색을 위해 여러가지 기하학적 도형 정보를 관리할 수 있는 데이터 타입을 제공한다. 여기서 GEOMETRY는 나머지 3개 타입의 수퍼타입이다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/a0676ffc-4c02-49b0-8651-c3be0f634d4d)

MBR이란 Minimum Bounding Rectangle의 약자로 도형을 감싸는 최소 크기의 사각형을 의미한다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/bc368f7f-3536-4a2e-994f-e4471a39b2c9)

이 사각형들의 포함 관계를 B-Tree 형태로 구현한 인덱스가 R-Tree이다.

### 용도

거리 비교하는 검색에 사용할 수 있다.

ST_Contains, ST_Within 함수를 사용해 MBR로 포함 관계 비교를 수행한다.

정확한 거리가 아닌, 사각형 안에 포함되는 값이기 때문에 ST_Distance_Sphere 함수를 사용해 다시한번 필터링하면 정확히 거리내의 좌표인지 알 수 있다.

# 전문 검색 인덱스

MyISAM은 인덱스 키값의 크기를 1000 바이트, InnoDB는 3072 바이트까지만 잘라서 사용하기 때문에, 키값 전부를 사용하지 않을 수 있다. 따라서 전체 일치 또는 좌측 일치와 같은 검색만 가능하다.

문서 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 전문 검색에는 일반적인 B-Tree 인덱스를 사용할 수 없다.

### 인덱스 알고리즘

- 어근 분석 알고리즘
    
    전문 검색 인덱스는 불용어 처리와 어근 분석 후 색인 작업이 수행된다.
    
    - 불용어 처리
        
        불용어 설정이 되어있지만, 한글의 경우 문장의 형태소를 분석하는 기능이 더 중요하다. 외부 플러그인을 많이 사용하기도 한다.
        
- n-gram 알고리즘
    
    키워드를 검색해내기 위한 인덱싱 알고리즘, n글자 단위로 쪼개서 인덱싱 하는 방법으로 2-gram 방식을 많이 사용한다.
    
- 불용어 변경 및 삭제
    
    my.cnf 파일에 ft_stopword_file 변수에 지정해도 되고, innodb_ft_enable_stopword 시스템 변수를 OFF로 설정하면 꺼지게 된다.
    

### 전문 검색 인덱스의 가용성

- 쿼리 문장이 전문 검색을 위한 문법이어야 한다. (MATCH … AGAINST … )
    
    `SELECT * FROM table WHERE MATCH(doc_body) AGAINST('검색어', IN BOOLEAN MODE);` 
    
- 테이블이 전문 검색 대상 칼럼에 대해 전문 인덱스를 보유한다.

# 함수 기반 인덱스

MySQL 8.0부터 지원하는 기능으로, 가상 칼럼을 이용하거나 함수를 이용해 인덱싱한다. 실제 내부 구조는 B-Tree와 동일하다.

### 가상 칼럼

CONCAT(first_name, ‘ ‘, last_name)을 인덱싱 하려면 `ADD … AS ... VIRTUAL` 을 사용해 가상 인덱스를 생성할 수 있다.

가상 칼럼은 실제 새로운 컬럼을 추가하는 방법과 같아서 테이블 구조가 변경되는 단점이 있다.

### 함수를 이용한 인덱스

MySQL 8.0 부터 테이블의 구조를 변경하지 않고 함수를 직접 사용하는 인덱스를 생성할 수 있어졌다.

인덱스를 사용하려면 반드시 조건절에 명시된 표현식과 동일하게 사용되어야 한다.

# 멀티 밸류 인덱스

하나의 데이터에 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스다. JSON 타입을 지원하면서 생겼다.

멀티 밸류 인덱스는 다음과 같은 함수를 이용해서 검색해야 한다.

- MEMBER OF()
- JSON_CONTAINS()
- JSON_OVERLAPS()

# 클러스터링 인덱스

클러스터링 인덱스는 PK에 대해서만 적용된다. 중요한 점은 PK값에 의해 레코드의 저장 위치가 결정된다. 따라서 PK가 변경되면 저장 위치가 변경된다.

클러스터링 인덱스가 되는 우선순위는 다음과 같다.

1. PK
2. NOT NULL + Unique
3. 자동으로 Unique한 값을 가지는 컬럼을 추가한 후 키로 선택

클러스터링 인덱스는 세컨더리 인덱스에서 RowID로 검색할 때 사용된다. 

장점

- 검색 처리 성능이 매우 빨라졌다.
- 인덱스만으로 처리되는 경우가 많음

단점

- 인덱스의 크기가 커진다.
- 세컨더리 인덱스로 검색하게 되면 PK로 다시 한번 검색해야 한다.
- Insert할때 위치가 정해지기 때문에 느리다.
- PK를 변경할 때 삭제 후 생성하기 때문에 느리다.

세컨더리 인덱스의 리프 노드에는 PK가 저장되어 있기 때문에 PK의 크기가 크면 인덱스의 크기가 커지게 된다.

PK는 매우 중요하게 쓰이기 때문에 신중하게 선택해야 하는데, AUTO-INCREMENT보다 업무으로 테이블을 대표할 수 있는 컬럼으로 지정하는 것이 좋다.

PK를 지정하지 않는 경우 내부적으로 컬럼을 생성하게 되는데, 이는 사용자에게 보이지 않기 때문에 사용자가 접근할 수 없다. 따라서 AUTO-INCREMENT라도 지정을 하는 것이 좋다.

# 유니크 인덱스

유니크는 인덱스보단 조건에 가깝다. Null도 저장되는데 이는 특별한 값이 아니므로 여러개 저장이 가능하다.

### 유니크 인덱스와 세컨더리 인덱스 비교

구조상 아무런 차이점이 없다.

읽기 - 유니크의 경우 1개의 값만 읽으면 되지만, 세컨더리 인덱스는 중복을 허용하므로 이를 처리해줘야 한다.

쓰기 - 유니크 인덱스는 중복값 체크할 때 읽기 락을 쓰고, 생성할 때 쓰기 락을 사용하기 때문에 데드락이 빈번히 발생한다. 또한 버퍼도 사용할 수 없다. 따라서 세컨더리 인덱스보다 느리다.

### 주의사항

불필요한데 유니크 인덱스를 남발하지 말자. 가끔 유니크 인덱스와 일반 인덱스를 동시에 생성하는 경우도 있는데, 이미 같은 역할을 하기 때문에 중복할 필요는 없다.

# 외래키

외래키 제약이 설정되면, 연관 테이블 컬럼에 인덱스를 생성한다. 외래키가 제거되지 않은 상태에서 자동으로 생성된 인덱스를 삭제할 수 없다.

외래키에는 두가지 특징이 있다.

- 테이블 쓰기 잠금이 발생한 경우에만 잠금 경합이 발생한다.
    
    부모 테이블이 데이터를 변경하는 도중에 자식 테이블에서 외래키 칼럼을 변경(INSERT, UPDATE)하는 경우에는 지연된다.
    
    자식 테이블에서 데이터를 변경하는 도중에 부모 테이블에서 레코드를 삭제하면 지연된다. 이는 CASCADE 옵션 때문에 동시에 삭제하는 경우에만 유효하다.
    
- 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합을 발생시키지 않는다.
