## 8.8 클러스터링 인덱스
- 클러스터링: 여러 개를 하나로 묶는다는 의미로 주로 사용
  - 군집화, 비슷한 것의 묶음 

- **`클러스터링 인덱스`** : **테이블의 레코드를 비슷한 것(PK 기준)들끼리 묶어서 저장하는 형태**
  - 프라이머리 키 값에 의해 레코드의 저장 위치가 결정 됨 → PK 이동시 위치 변경

- MySQL에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원
  - MyISAM은 ROWID → 변하지 않는 메모리 주소 값

### 8.8.1. 클러스터링 인덱스
- PK에만 적용, PK 값이 비슷한 레코드끼리 묶어서 저장하는 것 
  - **`PK 값에 의해 레코드의 저장 위치가 결정됨`**
  
  - **`PK 값이 변경된다면 레코드의 물리적인 저장 위치가 변경됨`**

  - 인덱스 알고리즘 보다는 `테이블 레코드의 저장 방식`으로 볼 수 있음
    - 클러스터링 인덱스와 클러스터링 테이블은 동의어로 사용됨 

- 클러스터링 인덱스로 저장되는 테이블은 **`PK 기반의 검색이 매우 빠르고, 레코드의 저장이나 PK의 변경이 상대적으로 느림`**

- PK 값에 대한 의존도가 크기 때문에 **`신중히 PK를 선정해야함`**

- 클러스터링 테이블(인덱스)의 구조

  ![스크린샷 2023-08-15 오후 5 34 43](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/efe5e1bc-04fe-4d1f-b6fd-14c11016ec0a)

- 일반 B-Tree와 비슷하지만 세컨더리 인덱스를 위한 B-Tree의 리프 노드와는 달리 클러스터링 인덱스의 리프 노드에는 레코드의 **`모든 컬럼이 같이 저장돼 있음`**
  - 즉, 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리되는 것
  
  - PK가 변경되면 인덱스 내의 위치가 바뀜

    ![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/aeab5844-a3bf-4b57-a2fd-a982f6292131)

#### **`PK가 없는 테이블의 경우(PK 선정 과정)`**
1. PK가 있으면 기본적으로 PK를 클러스터링 키로 선택
  
2. NOT NULL 옵션의 유니크 인덱스(UNIQUE INDEX) 중 첫 번째 인덱스를 클러스터링 키로 선택
   
3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후 클러스터링 키로 선택

⚠️ **`[주의]`** **자동으로 추가된 컬럼은 사용자에게 노출되지 않고 명시적으로 사용할 수 없음**
  - 즉, PK나 유니크 인덱스가 없는 테이블은 아무 의미 없는 숫자 값으로 클러스터링 되고 아무런 혜택이 없음

### 8.8.2 세컨더리 인덱스에 미치는 영향
- 만약, InnoD에서 세컨더리 인덱스가 실제 레코드가 저장된 주소를 가지고 있다면?
  - 클러스터링 키 값이 변경될 때마다 레코드 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 함

  - 즉, **오버헤드가 많아짐**

- 이런 오버헤드를 제거하기 위해, InnoDB의 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 PK 값을 저장하도록 구현됨
  - MyISAM: 세컨더리 인덱스를 검색해서 레코드의 주소 확인 후 레코드 주소(ROWID)를 이용해 최종 레코드를 가져옴

  - InnoDB: **`세컨더리 인덱스를 검색해 레코드의 PK 값을 확인 후, PK 인덱스를 검색해서 최종 레코드를 가져옴`**

- InnoDB가 MyISAM 보다 복잡하게 처리됨 → 더 큰 장점이 있기 때문에 성능 저하를 걱정하지 않아됨

### 8.3.3. 클러스터링 인덱스의 장점과 단점
**`장점`**
- 프라이머리 키(클러스터링 키)로 검색할 때 처리 성능이 매우 빠름(특히, 프라이머리 키를 범위 검색하는 경우 매우 빠름)

- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음(이를 커버링 인덱스라고 함)

**`단점`**
- 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐

- 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림 

- INSERT할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림

- 프라이머리 키를 변경할 때 레코드를 DELETE하고 INSERT하는 작업이 필요하기 때문에 처리 성능이 느림

**`결론`** 
- **`빠른 읽기와 느린 쓰기`**

  - OLTP환경 에서는 읽기와 쓰기 비율이 8:2, 9:1 정도이기 때문에 조금 느린 쓰기를 감수하고 읽기를 빠르게 유지하는 것이 더 중요함

### 8.8.4 클러스터링 테이블 사용 시 주의 사항

#### 8.8.4.1 클러스터링 인덱스 키의 크기
- `모든 세컨더리 인덱스는 PK(클러스터링 키) 값을 포함`

- 일반적으로 테이블에 세컨더리 인덱스가 4~5개 정도 생성된다는 것을 고려하면 세컨더리 인덱스의 크기는 급격히 증가함

- 인덱스의 크기가 클수록 동일 성능을 내기 위해 메모리가 더 필요하기에 PK는 신중하게 선택해야 함

#### 8.8.4.2 프라이머리 키는 AUTO-INCREMENT 보다는 업무적인 칼럼으로 생성(가능한 경우)
- PK는 검색에서 엄청난 차이를 만들어 내기 때문에 빈번하게 사용됨

- `크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있는 칼럼을 PK로 설정하자`

#### 8.8.4.3 프라이머리 키는 반드시 명시할 것
-` PK는 AUTO-INCREMENT 칼럼을 이용해서라도 명시하는 것을 권장함`
  - PK를 명시하지 않으면 내부적으로 일련번호 컬럼을 추가하지만 사용자가 이용할 수 없음 → 장점 활용 불가

- ROW 기반의 복제나 InnoDB Cluster에서는 모든 테이블이 PK를 가져야만 하는 정상적인 복제 성능을 보장

#### 8.8.4.4 AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우
- 여러 개의 칼럼이 복합으로 PK가 만들어지는 경우 PK의 크기가 길어질 때가 있음

- 하지만, PK의 크기가 길어도 세컨더리 인덱스가 필요치 않다면 그대로 PK를 사용하는 것이 좋음

- 세컨더리 인덱스도 필요하고 PK의 크기도 길다면 AUTO_INCREMENT 컬럼을 추가하고 PK로 설정
  - 이렇게 PK를 대체하기 위해 인위적으로 추가된 PK를 `인조 식별자(Surrogate Key)`라고 함

- 로그 테이블과 같이 조회보다는 INSERT 위주의 테이블들은 인조 식별자를 PK로 설정하는 것이 성능 향상에 도움이 됨

##### AUTO-INCREMENT VS UUID (토의 주제)
- https://stir.tistory.com/294

- [RDB에서 UUID를 사용할 때 고민해볼점](https://velog.io/@devkingsejong/RDB%EC%97%90%EC%84%9C-UUID%EB%A5%BC-%EB%AC%B4%EC%9E%91%EC%A0%95-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%90%EC%95%84%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)

- https://devs0n.tistory.com/39, https://devs0n.tistory.com/87

- [MySQL_UUID의 개념과 성능 개선 결과](https://chanos.tistory.com/entry/MySQL-UUID%EB%A5%BC-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EB%85%B8%EB%A0%A5%EA%B3%BC-%ED%95%9C%EA%B3%84)

- 밑의 스크마 구조에서 oauthId와 provider를 합쳐서 pk로 설정해도 되는가?

  ![스크린샷 2023-08-15 오후 7 09 56](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/49ae1d4c-afd2-47b0-9511-c9ce386773c5)

## 8.9 유니크 인덱스
- **유니크는 인덱스라기보다 제약 조건에 가까움**
  - 테이블/인덱스에 같은 값이 2개 이상 저장될 수 없도록

  - MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법은 없음

- 유니크 인덱스에는 **`NULL도 저장될 수 있고, NULL은 특정 값이 아니므로 2개 이상 저장도 가능`**

- MySQL의 PK에는 기본적으로 NULL을 허용하지 않는 유니크 속성이 자동으로 부여됨
  - InnoDB 테이블의 **`PK는 클러스터링 키의 역할도 하기 때문에 유니크 인덱스와는 근본적으로 다름`**

### 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교
- **`유니크 인덱스와 일반 세컨더리 인덱스(Non-유니크)는 사실 인덱스 구조상 아무런 차이점이 없음`**

- 성능의 관점에서 보면 읽기, 쓰기 동작의 약간의 차이가 있음

#### 8.9.1.1 인덱스 읽기
- 유니크 인덱스가 빠르다는 것은 사실이라고 보기 어려움
  - 유니크하지 않은 세컨더리 인덱스는 중복된 값을 허용하므로 읽어야 할 레코드가 많아서 느린 것
    
  - `인덱스 자체의 특성 때문에 느린 것은 아님`
    - 디스크 읽기가 아닌 CPU에서 칼럼 값을 비교하는 작업이 추가될 뿐

    - 1개를 읽느냐 2개를 읽느냐의 차이만 있음 

  - 즉, 읽어야 할 레코드 건수가 같다면 성능 차이가 미미함

#### 8.9.1.2 인덱스 쓰기
- **`유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 확인하는 과정이 필요해서 상대적으로 쓰기 작업이 느림`**

- MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 떄는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용하는데 이 과정에서 데드락이 아주 빈번히 발생함

- InnoDB 스토리지 엔진에는 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼(Change Buffer)가 사용됨 → 저장, 변경 작업이 빠름
  - 유니크 인덱스는 중복 체크를 해야 하기 때문에 버퍼링을 사용할 수 없음 → 변경 작업이 더 느림

### 8.9.2 유니크 인덱스 사용 시 주의사항
- 유니크 조건이 필요하다면 사용하는 것은 당연하지만, 성능의 이점을 위해서는 불필요하고 오히려 좋지 않음

- MySQL의 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하므로 중복해서 세컨더리 인덱스를 생성할 필요는 없음

- 같은 칼럼에 대해 PK, 유니크 인덱스를 동일하게 생성하는 경우도 불필요한 중복

- **`유일성이 꼭 보장돼야 하는 칼럼에 대해서는 유니크 인덱스를 생성하되, 꼭 필요하지 않다면 세컨더리 인덱스를 생성하는 방법도 고려하자`**

## 8.10 외래키
- MySQL에서 외래키(FK)는 InnoDB만 생성 가능

- 외래키 제약 설정시 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성됨   
  - 외래키가 제거되지 않은 상태에서는 인덱스를 삭제할 수 없음

- **`InnoDB 외래키의 두 가지 특징`**  
  - 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다

  - 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다

### 8.10.1 자식 테이블의 변경이 대기하는 경우

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/617601cf-2f67-4fe1-9666-88c631495366)

- 4번 작업번호에서 부모 테이블의 변경 작업이 완료될 때까지 기다림

- 1번 커넥션에서 작업을 완료했을 때 2번 커넥션에서 대기중이던 작업이 즉시 처리

- **`부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때까지 기다리게됨`**

- **`자식 테이블의 외래키(pid)가 아닌 칼럼(tb_child 테이블의 fd 칼럼과 같은)의 변경은 외래키로 인한 잠금 확장(바로 위에서 살펴본 예제와 같은)이 발생하지 않음`**

### 8.10.2 부모 테이블의 변경 작업이 대기하는 경우

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/99165624/a19b7eeb-bf83-4d60-84e8-6ff64bfcd5ef)

- 1 커넥션에서 부모키 1을 참조하는 자식 테이블의 레코드를 변경하면, 자식 테이블의 레코드에 대해 쓰기 잠금을 획득

- 이 상태에서 부모 테이블에서 id가 1인 레코드를 삭제하면, 자식 테이블의 레코드에 대한 쓰기 잠금이 해제될 때까지 기다려야 한다

- 자식 테이블이 생성될 때 정의된 외래키의 특성(ON DELETE CASCADE) 때문에 부모 레코드가 삭제되면 자식 레코드도 동시에 삭제되는 식으로 작동하기 때문에
    
#### FK 사용해야 하는가? (토의 주제)
- 데이터베이스에서 외래 키를 물리적으로 생성하려면 잠금 경합까지 고려해서 모델링을 해야 함

- 물리적인 외래키의 고려사항은, **`‘체크 작업’이 아니라 체크를 위해 연관 테이블에 읽기 잠금을 걸어야 한다는 것`**

- 이러한 잠금이 다른 테이블로 확장되면, 그만큼 전체적으로 **쿼리의 동시처리에 영향을 미침**

- 데이터 정합성 VS 성능

##### 참고
- [DB 외래키 foreign key 사용을 하는게 좋을까](https://juns-life.tistory.com/entry/DB-%EC%99%B8%EB%9E%98%ED%82%A4-foreign-key-%EC%82%AC%EC%9A%A9%EC%9D%84-%ED%95%98%EB%8A%94%EA%B2%8C-%EC%A2%8B%EC%9D%84%EA%B9%8C)

- https://brunch.co.kr/@dan-kim/26

- https://burndogfather.com/258
  
- https://co1nam.tistory.com/44
