MySQL에서 옵티마이저는 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하며, 최적의 실행 계획을 수립하는 작업을 한다.

EXPLAIN 명령을 통해 실행 계획을 볼 수 있는데, 이 내용을 모두 이해하려면 옵티마이저가 실행하는 최적화에 대해 어느정도 지식을 갖추고 있어야 한다.

# 개요

### 쿼리 실행 절차

1. 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리 한다. (파스 트리)
2. 파스 트리를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 사용할지 선택한다.
3. 2번에서 결정된 내용으로 스토리지 엔진으로부터 데이터를 가져온다.

1번을 SQL 파싱이라고 하며 SQL 파서 모듈이 파스 트리를 만든다. - MySQL엔진에서 처리

2번은 파스 트리를 참조해 다음과 같은 내용을 처리한다. - MySQL엔진에서 처리, 실행 계획 완성

- 불필요한 조건 제거 및 복잡한 **연산 단순화**
- 여러 테이블 **조인이 있는 경우 순서**를 결정한다.
- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 **사용할 인덱스 결정**
- 가져온 레코드들을 임시 테이블에 넣고 **다시 한번 가공해야 하는지 결정**

3번은 수립된 계획 대로 레코드를 읽어 오도록 요청하고, 조인하거나 정렬한다. - MySQL엔진과 스토리지 엔진이 처리한다.

이 단계 외에도 여러가지 단계가 있지만 중요한건 위 세가지이다.

### 옵티마이저 종류

- RBO - 규칙 기반 최적화
    
    다른 옵션은 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식
    
    현재는 사용되지 않는다.
    
- CBO - 비용 기반 최적화
    
    각 단위 작업의 비용, 정보와 대상 테이블의 예측된 통계를 이용해 실행 계획별 비용을 산출한다.
    
    실행 비용이 최소로 소요되는 처리 방식을 선택한다.
    

# 기본 데이터 처리

### 풀 테이블 스캔과 풀 인덱스 스캔

- 풀 테이블 스캔
    
    테이블의 데이터를 처음부터 끝까지 읽어서 작업을 처리하는 것. 보통 다음 조건에서 사용된다.
    
    - 테이블 레코드 건수가 너무 작아서 인덱스를 읽는 것보다 더 빠른 경우(페이지 1개)
    - Where 절이나 On절에 인덱스를 사용할 수 있는 조건이 없는 경우
    - 인덱스 레인지 스캔을 하더라도 조건 일치 레코드 건수가 너무 많은 경우
    
    InnoDB에서 풀테이블 스캔을 하면 여러개의 페이지를 한 번에 읽어올 수 있다.
    
    InnoDB에서 특정 테이블의 연속된 페이지가 읽히면 백그라운드 스레드에 의해 Read ahead 작업이 자동으로 시작된다.
    
    Read ahead - 백그라운드 스레드가 4개 또는 8개씩 페이지를 읽어서 최대 64개까지 버퍼 풀에 저장해 둔다.
    
- 풀 인덱스 스캔
    
    풀 테이블 스캔과 동일하게 Read ahead 작업이 사용된다.
    

### 병렬 처리

MySQL 8.0 부터 where조건 없이 테이블 전체 건수를 가져오는 쿼리는 병렬 처리가 가능해졌다.

`innodb_parallel_read_threads` 라는 시스템 변수를 통해 최대 몇개의 스레드를 이용할지 변경할 수 있다.

병렬 처리를 하면 쿼리 처리 속도가 더 빨라지지만, 서버 CPU 코어 개수보다 많아지면 성능이 떨어질 수 있다.

### ORDER BY 처리

정렬을 하는 방법은 인덱스를 이용하는 법과 Filesort를 사용해 처리하는 방법으로 나눌 수 있다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/291a313c-3aa0-4227-bf44-36fb1402c550)


어떤 정렬 방식을 사용하는지 보려면 실행계획의 Extra 컬럼을 보자.

모든 정렬은 Filesort를 이용하지 않는다. 다음과 같은 상황에서 인덱스를 사용하지 못한다.

- 정렬 기준이 너무 많아서 요건별로 인덱스 생성이 불가능한 경우
- GROUP BY의 결과 또는 DISTINCT같은 처리의 결과를 정렬해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

**소트 버퍼**

정렬을 수행하기 위한 메모리 공간을 뜻한다.

할당받은 메모리 공간은 필요에 의해 가변적으로 변하지만, `sort_buffer_size` 시스템 변수로 설정할 수 있다.

소트 버퍼만으로 모두 정렬할 수 있다면 좋겠지만, 소트 버퍼 공간으로 부족한 경우에는 임시 저장을 위해 디스크를 사용한다.

소트 버퍼에서 정렬을 하고 결과를 임시 디스크에 기록해둔다. 이 방법을 반복해서 수행하고, 정렬된 레코드를 병합하며 다시 정렬한다. (멀티 머지) 수행된 멀티 머지 횟수는 상태 변수에 누적 집계된다.

멀티 머지는 많은 디스크 I/O를 유발한다. 그렇다고 소트 버퍼 크기를 크게 설정해도 큰 차이는 없다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/851d2a52-8704-43cd-833e-c7fbd4ce7e49)


소트 버퍼는 세션 메모리기 떄문에 정렬 작업이 많고, 소트 버퍼를 많이 할당하게 되면 OS의 메모리 공간이 부족할 수 있다.

**정렬 알고리즘**

- Single-pass - 레코드 전체를 소트 버퍼에 담는 방법
    
    ![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/d21f57b1-eb3d-4f71-8fd6-21254b5f524b)

    
    처음 테이블을 읽을때 모든 컬럼을 읽어서 소트 버퍼에 담고 정렬을 수행한다. 소트 버퍼 공간이 많이 필요하다는 단점이 있다.
    
- Two-pass - 정렬 기준 컬럼만 소트 버퍼에 담는 방법
    
    Single-pass가 도입되기 전부터 사용하던 방식이고, 여전히 사용되는 방식이다. 최신 버전에서는 Single-pass를 주로 사용한다. 다만 레코드 크기가 `max_length_for_sort_data` 시스템 변수보다 크거나, BLOB이나 TEXT 타입의 컬럼이 SELECT 대상에 포함된 경우 Two-pass를 사용한다.
    
    ![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/8f327ddb-ba39-4662-941b-74d58b0a3880)

    
    정렬에 필요한 컬럼과 rowid만 읽어서 정렬을 수행한다. 이 방식은 테이블을 두 번 읽어야 한다는 단점이 있다.
    
    일반적으로 레코드 크기가 크거나 많은 경우 Two-pass를 유리하고, 반대 상황에서 Single-pass가 유리하다.
    

다음과 같이 볼 수 있다.

```java
-- 옵티마이저 트레이스 활성화 
SET OPTIMIZER_TRACE="enabled=on", END_MARKERS_IN_JSON=on;
SET OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;

-- 정렬 쿼리 아무거나 실행
SELECT ...

-- 트레이스 내용 확인
SELECT * FROM INFORMATION_SCHEMA.OPTINIZER_TRACE \G
```

트레이스 내용에는 limit, 사용가능한 메모리, 키사이즈, 로우사이즈, 로우 버퍼, 정렬 알고리즘 등이 나온다.

sort_algorithm은 정렬을 수행할때 사용되는 라이브러리를, sort_mode는 3가지가 있다.

<sort_key, rowid> - 정렬 키와 레코드의 row id만 가져와서 정렬

<sort_key, additional_fields> - 정렬 키와 레코드 전체를 가져와서 정렬, 레코드 컬럼은 고정 사이즈로 메모리에 저장

<sort_key, packed_additional_fields> - 정렬 키와 레코드 전체를 가져와서 정렬, 레코드 컬럼은 가변 사이즈로 메모리에 저장

**정렬 처리 방법**

정렬 처리 방법은 속도 순으로 세가지가 있다.

1. 인덱스를 사용한 컬럼 - 별도 표기 없음
2. 조인에서 드라이빙 테이블만 정렬 - Using filesort 표시됨
3. 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 - Using temporary; Using filesort 표시됨

옵티마이저는 1,2,3 순서로 하려고 하지만 안되는 경우 정렬대상 레코드를 최소화하기 위해서 2가지 방법중 하나를 선택한다.

- 드라이빙 테이블만 정렬한 다음 조인을 수행
- 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행

일반적으로 조인을 수행하면 레코드 건수와 크기는 배로 불어나기 때문에 1번째 방법이 더 효율적이다.

**인덱스를 이용한 정렬**

인덱스는 정렬되어 있기 때문에 별도의 정렬 없이 그대로 읽어오면 된다.

정렬에 인덱스를 이용하려면 반드시 ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블에 속하고 ORDER BY 순서대로 생성된 인덱스가 있어야 한다. 그리 B-Tree를 제외한 다른 트리는 이 방법을 사용할 수 없고, 여러 테이블이 조인되는 경우에는 NL 방식만 사용가능하다.

**조인에서 드라이빙 테이블만 정렬**

이 방법을 사용하면 조인에서 드라이빙 테이블의 칼럼만으로 ORDER BY절을 작성해야 한다.

**임시 테이블을 이용한 정렬**

2개 이상의 테이블을 조인해서 정렬해야 한다면 임시테이블이 필요할 수 있다.

**정렬 처리 방법 성능 비교**

LIMIT는 MySQL 서버의 작업량을 줄이는 역할을 한다. 보통 ORDER BY와 LIMIT를 함께 사용하는데, ORDER BY와 GROUP BY와 함꼐 사용되는 경우 LIMIT의 이점을 살릴 수 없다.

쿼리에서 인덱스를 사용하지 못하는 정렬이나 그루핑이 왜 느린지 알아보자

- 스트리밍 방식 (인덱스 정렬)
    
    조건에 일치하는 레코드가 검색될 때마다 바로 클라이언트에 전송하는 방식, MySQL 서버는 데이터 가공을 빠르게 시작할 수 있다. 따라서 레코드 수에 상관 없이 빠른 응답 시간을 보장한다.
    
- 버퍼링 방식 (드라이빙 테이블 정렬, 임시 테이블 정렬)
    
    ORDER BY나 GROUP BY는 스트리밍이 정렬/그루핑 하여 차례대로 보내야 하기 때문에 불가능하다. 그동안 MySQL 서버는 아무 작업을 할 수 없기 때문에 응답 속도가 느리다.
    

정렬 처리 성능은 드라이빙 테이블, 정렬 방법이 좌우한다. 따라서 최대한 빠른 방식으로 유도하는 것이 중요하다.

**정렬 관련 상태 변수**

정렬을 수행하며 몇건의 레코드를 정렬 했는지, 멀티 머지는 몇번 발생했는지 조회할 수 있다.

```java
FLUSH STATUS;
SHOW STATUS LIKE 'Sort%';
```

### GROUP BY

GROUP BY는 ORDER BY와 같이 쿼리가 스트리밍 처리를 할 수 없게 한다.

HAVING절에 사용되는 조건은 인덱스를 사용할 수 없으므로 HAVING절에 대한 튜닝을 필요 없다.

반면에, GROUP BY 작업에 인덱스를 사용하는 경우가 있다. (인덱스 스캔, 루스 인덱스 스캔)

**타이트 인덱스 스캔**

드라이빙 테이블에 속한 컬럼만 이용해 GROUPING을 할 때 인덱스가 있다면 그 인덱스를 차례로 읽으면서 그루핑을 수행하고, 조인한다. 이때는 추가적인 정렬이나, 임시테이블은 필요하지 않다.

그룹 함수등의 그룹값을 처리해야 할땐 임시테이블을 필요로 한다.

실행 계획에선 Extra 컬럼에 Using index for group-by 또는 Using temporary, Using filesort가 표시되지 않는다.

**루스 인덱스 스캔**

실행 계획에선 Extra 컬럼에 Using index for group-by 가 표시된다.

```jsx
SELECT emp_no
FROM salaries
WHERE from_date = '1985-03-01'
GROUP BY emp_no;
```

인덱스는 (emp_no, from_date)인 상황에서 다음과 같은 쿼리를 날리면 where 조건으로 인덱스 레인지 스캔을할 수 없다.

하지만 실행계획을 보면 Using where; Using index for group-by가 나타나 있는데 어떻게 된걸까

1. (emp_no, from_date) 인덱스를 스캔하면서 emp_no의 첫 번째 그룹키를 찾아낸다.
2. 1에서 찾은 그룹키 중에서 from_date값이 이리하는 레코드만 가져온다.
따라서 1번값과 from_date값으로 찾는 것과 거의 흡사하다.
3. 다시 1, 2번 반복하다가 없으면 종료한다.

루스 인덱스 스캔은 단일 테이블에 대해 수행되는 GROUP BY만 가능하고, prefix index의 경우는 사용할 수 없다. 인덱스의 특성과 다르게 루스 인덱스 스캔은 카디널리티가 낮을수록 성능이 좋다.

**임시 테이블 사용**

인덱스를 전혀 사용하지 못할때 사용된다.

실헹계획에선 Extra 컬럼에 Using temporary가 표시된다.

MySQL 8.0 이전에는 묵시적으로 정렬까지 함께 했었는데, 더이상 진행되지 않아 Using filesort는 표시되지 않는다. 하지만, 명시적으로 정렬을 하는 경우 여전히 Using filesort가 표시된다.

MySQL 8.0 이후로는 내부적으로 GROUP BY에 사용된 컬럼으로 Unique 인덱스를 가진 임시 테이블을 만들어 중복제거와 집합 함수 연산을 수행한다.

### DISTINCT 처리

DISTINCT는 집합 함수와 함께 사용될 때와 아닐 때로 나뉜다

**DISTINCT without 집합 함수**

이 경우에는 내부적으로 GROUP BY와 동일한 방식으로 처리된다.

DISTINCT는 한 컬럼이 아니라 SELECT되는 모든 컬럼 조합을 Unique하게 한다 이 부분을 명심하자.

**DISTINCT with 집합 함수**

집합 함수 내에서 사용된 DISTINCT는 그 집합 함수 인자로 전달된 컬럼만 유니크 하도록 한다.

```jsx
SELECT COUNT(DISTINCT s.salary)
FROM employees e, salaries s
```

이 쿼리는 `COUNT(DISTINCT s.salary)` 를 처리하기 위해 내부적으로 임시 테이블을 사용한다. 하지만 실행 계획에는 임시 테이블을 사용한다는 메세지를 표시하지 않는다. 이는 salary 컬럼의 값만 저장하기 위한 임시 테이블을 사용하는데, salary 컬럼에 유니크 인덱스가 생성되어 느려질 수 있다.

이때는 사용되는 컬럼에 인덱스가 있다면 인덱스를 사용할 수 있다.

### 내부 임시 테이블 활용

여기서 내부라는 뜻은 `CREATE TEMPORARY TABLE` 로 생성된 임시 테이블과 다르기 때문이다.

다른 임시 테이블과 다르게 쿼리가 끝나면 자동으로 삭제된다.

**메모리/디스크 의 임시 테이블**

MySQL 8.0이전 메모리 - MEMORY, 디스크 - MyISAM

MySQL 8.0이후 메모리 - TempTable, 디스크 -InnoDB

사용되는 스토리지 엔진을 변경해 MEMORY의 메모리 낭비 문제, MyISAM의 트랜잭션 미지원 문제를 개선했다.

`internal_tmp_mem_storage_engine` 시스템 변수로 메모리에 사용되는 스토리지 엔진을 설정할 수 있고, `temptable_max_ram` 시스템 변수로 메모리 공간의 크기를 할당할 수 있다.

이보다 커진다면 디스크로 기록되는데 두가지 방법이 있는데 `temptable_use_mmap` 로 설정한다.

- MMAP 파일로 기록 - InnoDB로 전환하는 것보다 오버헤드가 적다.
- InnoDB 테이블로 기록

**임시 테이블이 필요한 쿼리**

대표적으로 임시 테이블을 생성하는 경우는 다음과 같다.

- ORDER BY와 GROUP BY에 명시된 컬럼이 다른 쿼리
- ORDER BY나 GROUP BY에 명시된 컬럼이 조인의 순서상 첫 번째가 아닌 쿼리
- ORDER BY나 GROUP BY가 동시에 존재하는 경우
- DISTINCT가 인덱스를 활용할 수 없는 경우
- UNION이나 UNION DISTINCT가 사용된 쿼리
- 쿼리 실행 계획에서 select_type이 DERIVED인 쿼리

**임시 테이블이 디스크에 사용되는 경우**

임시 테이블을 메모리에 생성하지 못하는 경우도 있다.

- UNION이나 UNION ALL에서 SELECT되는 컬럼 중 길이가 512 바이트를 넘는 경우
- GROUP BY나 DISTINCT 컬럼에서 512 바이트 이상인 경우
- 메모리 임시 테이블 크기가 `tmp_table_size` 또는 `max_heap_table_size` 시스템 변수보다 크거나 `temptable_max_ram` 보다 큰 경우

**임시 테이블 관련 상태 변수**

실행 계획에 Using temporary가 사용되면 임시테이블을 사용함을 알 수 있다. 근데 임시 테이블이 메모리에서 사용되는지 디스크에서 사용되는지 알 수 없을까?

```jsx
SHOW SESSION STATUS LIKE 'Created_tmp%';
```

명령을 통해 확인할 수있다.
