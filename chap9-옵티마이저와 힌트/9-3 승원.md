# 9-3

# 고급 최적화

옵티마이저는 옵션을 결합해 실행계획을 수립한다.

옵티마이저 옵션은 조인관련 옵션과 스위치 관련 옵션이 있다.

### 옵티마이저 스위치 옵션

`optimizer_switch` 시스템 변수로 제어한다.

여러개의 옵션을 세트로 묶어서 설정한다. 설정 값은 default, off, on 세가지이며 시스템 변수이기 때문에 전체, 커넥션 별로 모두 설정할 수 있다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/ce2a0f7e-ea6d-4c47-8763-a748f5bf4381)

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/3ceca7d1-59e2-4d20-987d-8a5ad5491189)

**MRR과 배치 키 액세스**

MRR은 (Multi-Range Read) 또는 DS-MRR(Disk Sweep MRR) 이라고 한다.

지금까지 MySQL 서버에서 지원한 조인 방식은 드라이빙 테이블의 레코드 한 건을 조인 대상 테이블의 레코드와 일치시키는 Nested Loop 방식이다.

서버 구조상 조인 처리는 MySQL 엔진이 처리하지만, 실제 레코드를 읽고 검색하는 부분은 스토리지 엔진이 담당한다. 

이때 드라이빙 테이블의 레코드 건별로 드리븐 테이블의 레코드를 찾으면 스토리지 엔진에서는 아무런 최적화를 할 수 없다. → 레코드를 버퍼에 가득 채운 뒤 조인하여 최적화 하는 방식을 MRR이라고 한다.

MRR을 응용해 조인하는걸 BKA(Batched Key Access)라고 하는데 부가적인 정렬 작업이 필요하다는 단점이 있어 비활성화 되어있다. 

**Block NL**

대부분은 NL 조인인데, 조인 조건 모두가 인덱스인 경우 사용되는 방식이다.

NL과 Block NL의 차이점은 조인 버퍼를 사용한다는 점과, 드라이빙 테이블과 드리븐 테이블의 레코드를 메모리에 캐싱하여 조인하는 형태로 처리한다. 이 방식을 조인 버퍼라고 하는데 조인 알고리즘의 Block 또는 실행 계획의 Extra 컬럼에 Using Join buffer 라는 문구가 표시된다.

실행 순서

1. 드라이빙 테이블의 인덱스를 사용해 조건 검색
2. 조인에 필요한 나머지 컬럼을 읽어서 조인 버퍼에 저장
3. 드리븐 테이블에 인덱스를 사용해 레코드 검색
4. 2, 3 결과를 조인 버퍼를 사용해 결합 후 반환

조인 버퍼가 사용되면 조인 순서가 거꾸로 처럼 실행된다.(정확히는 순서가 흐트러질 수 있다.)

MySQL 8.0.18 부터 해시 조인이 도입되어 사용하지 않는다.

**index_condition_pushdown**

MySQL 5.6 부터 도입된 기능으로, 인덱스를 사용한 검색을 하지 못할 때(column LIKE “%abc”) 라도 레코드를 읽고 판단하지 않고, 인덱스에서 판단할 수 있도록 하는 방법이다.

큰 기술 없이 큰 성능 개선을 할 수 있는 방법이다.

**use_index_extensions**

InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 PK를 활용할 수 있게 할지 결정한다. 

세컨더리 인덱스로 결국 클러스터 인덱스를 통해 값을 찾는데, 클러스터 인덱스 부분을 잘 활용하지 못했다.

MySQL이 업데이트 되면서 마지막에 클러스터 인덱스를 탐색하는 것을 인지하고 실행계획을 수립한다. (정렬에도 이점이 있음)

**index_merge**

인덱스를 이용해 쿼리를 실행하면 옵티마이저는 대부분  테이블 별로 하나의 인덱스만 사용하도록 한다.

인덱스 머지 실행 계획을 사용하면 하나의 테이블에 2개 이상의 인덱스를 이용해 쿼리를 처리한다.

보통은 테이블당 하나의 인덱스만 사용하는 것이 효율적이다. 하지만 각 조건이 반환하는 레코드가 많으면 index_merge를 사용한다.

**index_merge_intersection**

쿼리가 여러개의 인덱스를 각각 검색해서 그 결과의 교집합만 반환한다. 실행계획에선 Extra 컬럼에 Using intersect라고 표시된다.

2개 이상의 인덱스중 하나라도 효율적인 쿼리라면 사용되지 않는다.

`index_merge_intersection` 을 비활성화하면 사용하지 않는다. 현재/세션/글로벌로 설정 가능

**index_merge_union**

여러개의 인덱스를 각각 검색해서 합치는(OR) 경우이다. 합치는 과정에서 각 테이블은 PK로 정렬되어 있어 중복을 제거하기 편리하다.

**index_merge_sort_union**

두 결과의 중복을 제거하기 위해 정렬을 필요로 하는데 MySQL 서버는 별도로 수행하지 않는다.

결과가 정렬되지 않은 경우 Sort union 알고리즘을 사용해 쿼리를 정렬 후 병합한다.

**semijoin**

실제 조인하지 않고, 다른 테이블에 일치하는 레코드가 있는지 체크만 하는 것을 뜻한다.

MySQL 8.0부터 최적화 되어 속도가 빨라졌다.

- = subquery, IN subquery 의 경우 세미 조인, IN-to-EXISTS, MATERIALIZATION을 사용할 수 있다.
- <> subquery, NOT IN subquery의 경우 IN-to-EXISTS, MATERIALIZATION을 사용할 수 있다.
- 8.0부턴 Table Pull-out, Duplicate Weed-out, FirstMatch, Loose Scan, Materialization을 사용할 수 있다.

Table Pull-out은 세미 조인보다 성능이 좋아서 별도의 옵티마이저는 없다., First Match, Loose Scan은 옵티마이저 옵션으로 사용 여부를 결정하고, Duplicate Weed-out, Materialization은 옵티마이저 스위치로 사용 여부를 선택할 수 있따

**Table Pull-out**

세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어내 조인하는 형태

Table Pull-out 을 사용하는 경우 실행 계획의 id값이 같다.

모든 상황에서 사용할 수 없다.

- 세미 조인 서브쿼리에서만 사용 가능
- 서브쿼리 부분이 UNIQUE, PK 룩업으로 결과가 1인 경우에만 사용 가능
- 서브쿼리의 모든 테이블이 아우터 쿼리로 끄집어 낼 수 있다면 서브쿼리 자체는 없어진다. (서브쿼리는 최대한 조인으로 풀어 사용해라)

* 룩업 결과가 1인 경우 : 인덱스 검색을 1번 수행했음을 뜻한다.

**firstmatch**

IN subquery를 EXISTS subquery 형태로 뉴팅한 것 과 비슷하다.

실행계획엔 FistMatch(table)로 나온다. 조인 형태로 처리하기 때문에 아우터 쿼리의 테이블까지 전파가 가능하고, 선택할 수 있다.

모든 상황에서 사용할 수 없다.

- 서브쿼리가 참조하는 모든 아우터 테이블이 먼저 조회된 이후에 실행된다.
- 상관 서브쿼리(Correlated subquery)에서도 사용할 수 있다.
- GROUP BY나 집합 함수가 사용된 서브쿼리에 사용할 수 없다.

**loosescan**

Loose Index Scan과 비슷하다. 내부적으로 조인되어 처리되며 실행계획의 Extra 컬럼에 LooseScan이라고 표시된다.

Loose Index Scan으로 서브쿼리 테이블을 읽고 아우터 테이블을 드리븐으로 사용해 조인을 수행하는 방식이다.

서브쿼리가 루스 인덱스 스캔을 사용할 수 있어야 한다.

**Materialization**

서브쿼리를 통채로 구체화해서 최적화 하는 방식이다. 서브 쿼리로 임시 테이블을 생성한다는 것과 같은 의미이다.

실행 계획의 select_type컬럼에 MATERIALIZED라고 나타나며, 구체화된 테이블은 `<subquery2>.컬럼` 이런식으로 나타난다.

다른 방식과 달리 GROUP BY나 그룹 함수가 있어도 최적화 할 수 있다. 하지만, 상관 서브쿼리(Correlated subquery)인 경우에는 적용할 수 없다.

**Duplicated Weed-out**

세미 조인 서브쿼리를 일반적인 일반적인 INNER JOIN으로 바꿔 실행하고, 중복된 레코드를 제거한다.(GROUP BY) 테이블 조인이고, 집합 함수에도 사용할 수 있으며 상관 서브쿼리여도 실행할 수 있다.

순서는 다음과 같다.

1. 서브 쿼리의 결과를 사용해 조인을 실행
2. 1번의 결과는 임시 테이블에 저장
3. 중복 제거 후 반환

실행계획에 Start temporary, End temporary 사이가 처리과정을 뜻한다.

**condition_fanout_filter**

조인할 때 드라이빙 테이블을 결정하는 것은 성능과 깊은 연관이 있다. 조인 대상이 확연히 줄어들 수 있기 때문이다. condition_fanout_filter는 더 적은 레코드를 가진 조건의 쿼리를 드라이빙 테이블로 만들어 준다.

계산 조건은 다음과 같다.

- WHERE 조건절에 사용된 컬럼에 인덱스가 있는 경우
- WHERE 조건절에 사용된 컬럼에 히 스토토램이있경는 우경

**derived_merge**

기존의 MySQL 서버는 FROM 절에 사용된 서브쿼리는 먼저 실행해 임시 테이블로 만든 후 쿼리를 처리했다.

임시 테이블이 많아지면 오버헤드가 발생하기 때문에 MySQL 5.7부터 병합을 통한 최적화가 도입되었다.

실행 계획에 select_type에 DERIVED가 사라지고 단순하게 바뀐다. 자세한 사항은 `SHOW WARNINGS` 를 사용하자.

다음과 같은 상황에선 병합할 수 없어 수동 병합하는 것을 추천한다.

- 집계/윈도우 함수가 사용된 서브쿼리
- DISTINCT, GROUP BY, HAVING이 사용된 서브쿼리
- LIMIT, UNION, UNION ALL 이 사용된 서브쿼리
- SELECT 절에 사용된 서브쿼리
- 값이 변경되는 사용자 변수가 사용된 서브쿼리

**use_invisible_indexes**

인덱스를 삭제하지 않고 사용할 수 없게 하는 기능

**skip_scan**

MySQL 8.0부터 복합 인덱스의 후행 컬럼 조건만으로도 인덱스를 이용해 성능 개선이 가능하다.

선행 컬럼의 모든 값 + 후행 컬럼의 값으로 검색하여 병합한다. 당연히 선행 컬럼의 카디널리티가 낮아야 성능이 좋을 것이다.

**hash_join**

MySQL 8.0.18부터 생긴 기능으로 매우 빠른 성능을 보장할 것이라고 생각하지만 반은 틀린 말이다.

![image](https://github.com/Deep-Dive-Study/real-my-sql/assets/85796588/46e0db2e-a163-4798-825c-ebeff2a80df5)

NL에 비해 마지막 결과 값은 먼저 나오지만 첫 결과 값이 늦게 나오기 떄문이다. 따라서, 해시 조인은 NL의 차선책으로 생각하고 힌트로 지정하지 않는 것을 추천한다.

적절한 인덱스가 없어 NL을 사용하지 못하는 경우 Block NL 대신 사용되었는데, 버퍼의 크기 제한 때문에 해시조인을 사용하도록 변경되었다.

실행 단계는 Build, Probe로 나뉜다.

- Build - 해시 테이블로 만들기에 용이한 테이블을 메모리에 생성한다. (빌드 테이블)
- Probe - 나머지 테이블의 레코드를 읽어 해시테이블과 일치 시킨다. (프로브 테이블)

실행계획에는 hash join이라고 나타난다. 빌드 테이블을 알려면 `EXPLAIN FORMAT=TREE`를 사용하자

조인 버퍼의 공간이 부족한 경우 빌드/프로브 테이블을 청크로 분리하여 저장한다.

청크별로 저장하여 1차로 조인을 실행한 뒤 청크를 읽어 빌드테이블을 구축하고 청크 단위로 조인을 실행한다.

**prefer_ordering_index**

ORDER BY 또는 GROUP BY를 인덱스를 사용해 처리 가능한 경우 이 인덱스의 가중치를 높혀서 실행한다.

```java
EXPLAIN
SELECT *
FROM employees
WHERE hire_date BETWEEN '1985-01-91' AND *1985-02-01'
ORDER BY emp_no;

------------------------------------------------------------
|id | table     | type. | key     | rows   | Extra         |
------------------------------------------------------------
| 1 | employees | index | PRIMARY | 300252 | Using where   |
------------------------------------------------------------
```

이런 쿼리는 보통 2가지의 경우의 수가 있다

1. WHERE 조건의 인덱스를 찾은 다음 정렬
2. PK를 정순으로 읽으며 WHERE 조건을 비교

WHERE 조건에서 필터링할 수 있는 레코드가 많으면 1번이 효율적이겠지만 가끔은 2번을 선택하기도 한다.

만약 체크해야할 레코드가 많은데도 2번이 선택된 경우 힌트 또는 옵티마이저 옵션을 통해 변경할 수 있다.

### 조인 최적화 알고리즘

1. Exhaustive 검색
    
    MySQL 5.0과 그 이전에 사용되던 기법
    
    FROM절에 명시된 모든 테이블의 조합에 실행 계획 비용을 계산해서 최적의 조합 1개를 찾는다.
    
    조인되는 테이블이 많아질수록 N! 의 경우의 수가 나와 실행 계획 수립이 오래걸린다.
    
2. Greedy 검색
    
    1번의 시간 문제를 해결하기 위해 MySQL 5.0 부터 나온 기법
    
    1. N개의 테이블 중 `optimizer_search_depth` 시스템 설정 변수에 정의된 개수로 가능한 조인 조합을 생성
    2. 1번에서 최소 비용 조합 선정
    3. 2번에서 선정된 실행 계획의 첫 번째 테이블을 실행 계획 완료의 첫 번째 테이블로 선정
    4. 나머지 테이블로 1번~3번 반복
    
    * `optimizer_search_depth` : 0~62 설정 가능, 0이면 옵티마이저가 결정 / 성능에 큰 영향이 없다.
    
    * `optimizer_prune_level` : Heuristic 검색이 작동하는 방식 제어 1이 경험 기반이니 0으로 설정하지 말 것
